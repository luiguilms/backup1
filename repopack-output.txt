This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-09-19T19:48:20.364Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.gitignore
add-server.html
ag-grid.css
ag-theme-alpine.css
edit-server.html
index.html
insertServerInfo.js
main.js
package.json
preload.js
pruebas/cli.js
pruebas/connection.rdp
pruebas/index.js
pruebas/linux.js
pruebas/prueba.js
pruebas/readme.md
pruebas/rendererLinux.js
pruebas/rendererSolaris.js
pruebas/solaris.js
pruebas/ssh.js
pruebas/windows.js
pruebas/windows2.js
renderer.js
select-server.html
stylesAdd.css
stylesEdit.css
stylesIndex.css
stylesSelect.css

================================================================
Repository Files
================================================================

================
File: .gitignore
================
node_modules
.vscode

================
File: add-server.html
================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Agregar/Editar Servidor</title>
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="stylesAdd.css" />
  </head>
  <body>
    <h1 id="form-title">Agregar Servidor</h1>
    <form id="add-server-form">
      <div class="form-group">
        <label for="server-name">Nombre del Servidor:</label>
        <input type="text" id="server-name" name="server-name" required />
      </div>
      <div class="form-group">
        <label for="ip">Dirección IP:</label>
        <input type="text" id="ip" name="ip" required />
      </div>
      <div class="form-group">
        <label for="os">Sistema Operativo:</label>
        <select id="os" name="os">
          <option value="windows">Windows</option>
          <option value="linux">Linux</option>
          <option value="solaris">Solaris</option>
        </select>
      </div>
      <div class="form-group">
        <label for="port">Puerto:</label>
        <input type="text" id="port" name="port" value="22" />
      </div>
      <div class="form-group">
        <label for="username">Usuario:</label>
        <input type="text" id="username" name="username" required />
      </div>
      <div class="form-group">
        <label for="password">Contraseña:</label>
        <div class="password-container">
          <input type="password" id="password" name="password" required />
          <i class="far fa-eye toggle-password" id="togglePassword"></i>
        </div>
      </div>
      <button type="submit">Agregar Servidor</button>
    </form>
    <div id="success-message" style="display: none; color: green">
      Servidor agregado exitosamente.
    </div>
    <div id="error-message" style="display: none; color: red">
      Ocurrió un error al agregar el servidor.
    </div>
    <!-- Botón para retroceder -->
    <button id="back-button">Volver</button>

    <script>
      document
        .getElementById("back-button")
        .addEventListener("click", function () {
          window.location.href = "index.html"; // Cambia 'index.html' por la página a la que quieras redirigir
        });
    </script>
    <script>
      // Código para alternar la visibilidad de la contraseña
      const togglePassword = document.getElementById("togglePassword");
      const passwordField = document.getElementById("password");

      togglePassword.addEventListener("click", function (e) {
        // Cambiar el tipo de la entrada de contraseña
        const type =
          passwordField.getAttribute("type") === "password"
            ? "text"
            : "password";
        passwordField.setAttribute("type", type);

        // Cambiar el ícono al hacer clic
        this.classList.toggle("fa-eye-slash");
      });
    </script>
    <script src="renderer.js"></script>
  </body>
</html>

================
File: ag-grid.css
================

EL CONTENIDO DEL CSS ESTA EN INTERNET DESCARGUE EL ARCHIVO NADA MAS.

================
File: ag-theme-alpine.css
================

EL CONTENIDO DEL CSS ESTA EN INTERNET DESCARGUE EL ARCHIVO NADA MAS.

================
File: edit-server.html
================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Editar Servidor</title>
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="stylesEdit.css" />
  </head>
  <body>
    <h1 id="form-title">Editar Servidor</h1>
    <form id="edit-server-form">
      <div class="form-group">
        <input type="hidden" id="server-id" name="server-id" readonly />
      </div>
      <div class="form-group">
        <label for="server-name">Nombre del Servidor:</label>
        <input type="text" id="server-name" name="server-name" required />
      </div>
      <div class="form-group">
        <label for="ip">Dirección IP:</label>
        <input type="text" id="ip" name="ip" required />
      </div>
      <div class="form-group">
        <label for="os">Sistema Operativo:</label>
        <select id="os" name="os">
          <option value="windows">Windows</option>
          <option value="linux">Linux</option>
          <option value="solaris">Solaris</option>
        </select>
      </div>
      <div class="form-group">
        <label for="port">Puerto:</label>
        <input type="text" id="port" name="port" required />
      </div>
      <div class="form-group">
        <label for="username">Usuario:</label>
        <input type="text" id="username" name="username" required />
      </div>
      <div class="form-group">
        <label for="password">Contraseña:</label>
        <div class="password-container">
          <input type="password" id="password" name="password" required />
          <i class="far fa-eye toggle-password" id="togglePassword"></i>
        </div>
      </div>
      <button type="submit">Guardar Cambios</button>
    </form>

    <div id="success-message" style="display: none; color: green">
      Cambios guardados exitosamente.
    </div>
    <div id="error-message" style="display: none; color: red">
      Ocurrió un error al guardar los cambios.
    </div>

    <!-- Botón para retroceder -->
    <button id="back-button">Volver</button>

    <script>
      // Código para retroceder a la lista de servidores
      document
        .getElementById("back-button")
        .addEventListener("click", function () {
          window.location.href = "select-server.html"; // Cambia 'select-server.html' por la página a la que quieras redirigir
        });
    </script>
    <script>
      // Código para alternar la visibilidad de la contraseña
      const togglePassword = document.getElementById("togglePassword");
      const passwordField = document.getElementById("password");

      togglePassword.addEventListener("click", function (e) {
        // Cambiar el tipo de la entrada de contraseña
        const type =
          passwordField.getAttribute("type") === "password"
            ? "text"
            : "password";
        passwordField.setAttribute("type", type);

        // Cambiar el ícono al hacer clic
        this.classList.toggle("fa-eye-slash");
      });
    </script>
    <script src="renderer.js"></script>
  </body>
</html>

================
File: index.html
================
<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Conexión al Servidor</title>
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="stylesIndex.css" />
    <link rel="stylesheet" href="ag-grid.css" />
    <link rel="stylesheet" href="ag-theme-alpine.css" />
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
      rel="stylesheet"
    />
  </head>
  <body>
    <div class="container">
      <div class="card">
        <h1>Conexión al Servidor</h1>
        <form id="server-form">
          <div class="form-row">
            <div class="form-group">
              <label for="os">Sistema Operativo:</label>
              <select id="os" name="os">
                <option value="windows">Windows</option>
                <option value="linux">Linux</option>
                <option value="solaris">Solaris</option>
              </select>
            </div>
            <div class="form-group">
              <label for="ip">Dirección IP:</label>
              <select id="ip" name="ip">
                <!-- Las opciones de IP se llenarán dinámicamente -->
              </select>
            </div>
            <div class="form-group">
              <label for="port">Puerto:</label>
              <input type="text" id="port" name="port" value="22" />
            </div>
          </div>

          <div class="form-group">
            <label for="backup-routes">Rutas de Backup:</label>
            <select id="backup-routes" name="backup-routes">
              <!-- Las rutas de backup se llenarán dinámicamente -->
            </select>
          </div>

          <div class="form-row">
            <div class="form-group">
              <label for="username">Usuario:</label>
              <input type="text" id="username" name="username" required />
            </div>
            <div class="form-group">
              <label for="password">Contraseña:</label>
              <div class="password-container">
                <input type="password" id="password" name="password" required />
                <i class="far fa-eye toggle-password" id="togglePassword"></i>
              </div>
            </div>
          </div>

          <button type="submit">Conectar</button>
        </form>
      </div>
      <div class="card process-button-card">
        <button id="process-all-servers-btn">
          Procesar Todos los Servidores
        </button>
      </div>
        <div class="grid-wrapper">
          <div id="gridContainer" style="display: none">
            <div id="myGrid" class="ag-theme-alpine"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- Botón flotante con ícono de agregar servidor -->
    <button id="add-server-btn">
      <i class="fas fa-plus"></i>
      <span>Añadir</span>
    </button>

    <!-- Botón flotante con ícono de editar servidor -->
    <button id="edit-server-btn">
      <i class="fas fa-edit"></i>
      <span>Editar</span>
    </button>
    <div id="authErrorModal" class="modal">
      <div class="modal-content">
        <span id="closeModal" class="close">&times;</span>
        <p id="errorMessage">
          Error de autenticación. Por favor, inténtelo de nuevo.
        </p>
        <button id="retryButton">Retry</button>
      </div>
    </div>
    <div id="loading-overlay" style="display: none">
      <div class="loader"></div>
      <p>Cargando...</p>
    </div>
    <div id="result" style="overflow-y: auto; max-height: 500px">
      <h2>Resultados de la verificación:</h2>
      <div id="log-entries"></div>
    </div>
    <script src="renderer.js"></script>
    <script src="https://unpkg.com/ag-grid-community@31.0.0/dist/ag-grid-community.min.noStyle.js"></script>
    <script>
      // Código para alternar la visibilidad de la contraseña
      const togglePassword = document.getElementById("togglePassword");
      const passwordField = document.getElementById("password");

      togglePassword.addEventListener("click", function (e) {
        // Cambiar el tipo de la entrada de contraseña
        const type =
          passwordField.getAttribute("type") === "password"
            ? "text"
            : "password";
        passwordField.setAttribute("type", type);

        // Cambiar el ícono al hacer clic
        this.classList.toggle("fa-eye-slash");
      });
    </script>
  </body>
</html>

================
File: insertServerInfo.js
================
const crypto = require('crypto');
const oracledb = require('oracledb');

// Clave de encriptación (debe ser segura y almacenada en un lugar seguro)
const encryptionKey = Buffer.from('0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef', 'hex');
const iv = Buffer.from('abcdef0123456789abcdef0123456789', 'hex');

// Función para encriptar
function encrypt(text) {
  console.log(`Encriptando: ${text}`); // Log para depurar
  let cipher = crypto.createCipheriv('aes-256-cbc', Buffer.from(encryptionKey), iv);
  let encrypted = cipher.update(text);
  encrypted = Buffer.concat([encrypted, cipher.final()]);
  return { iv: iv.toString('hex'), encryptedData: encrypted.toString('hex') };
}

// Conexión a la base de datos
async function insertServerInfo(id, ip, osType, port, user, password, serverName) {
  let connection;

  try {
    console.log("Encriptando usuario y contraseña...");
    // Encriptar el usuario y la contraseña
    const encryptedUser = encrypt(user);
    const encryptedPassword = encrypt(password);

    // Conectarse a la base de datos
    console.log("Conectando a la base de datos...");
    connection = await oracledb.getConnection({
      user: "USRMONBK",
      password: "USRMONBK_2024",
      connectString: "10.0.211.58:1521/MONBKPDB.cmac-arequipa.com.pe",
    });

    // Insertar los datos en la base de datos
    console.log("Insertando los datos en la base de datos...");

    const result = await connection.execute(
      `INSERT INTO ServerInfo (ID, IP, OS_Type, Port, EncryptedUser, EncryptedPassword, ServerName)
       VALUES (:id, :ip, :osType, :port, :encryptedUser, :encryptedPassword, :serverName)`,
      {
        id: id,
        ip: ip,
        osType: osType,
        port: port,
        encryptedUser: Buffer.from(JSON.stringify(encryptedUser)),
        encryptedPassword: Buffer.from(JSON.stringify(encryptedPassword)),
        serverName: serverName,
      },
      { autoCommit: true }
    );

    console.log("Datos insertados correctamente:", result);
  } catch (err) {
    console.error("Error al insertar datos en la base de datos:", err);
  } finally {
    if (connection) {
      try {
        await connection.close();
        console.log("Conexión a la base de datos cerrada.");
      } catch (err) {
        console.error("Error al cerrar la conexión a la base de datos:", err);
      }
    }
  }
}

// Ejemplo de uso: insertar un servidor
insertServerInfo(1, '10.0.212.172', 'windows', 22, 'bknetworker', 'BKn3t$$2017','info7021');
insertServerInfo(2, '10.0.212.4', 'linux', 22, 'oracle', 'oracle19cR3','switch');
insertServerInfo(3, '10.0.212.211', 'solaris', 22, 'oracle', 'oracle12cR2','bantprod');

================
File: main.js
================
//main.js
const { app, BrowserWindow, ipcMain } = require("electron");
const path = require("path");
const { Client } = require("ssh2");
const oracledb = require("oracledb");
const { Console } = require("console");
const crypto = require("crypto");
// Función para normalizar rutas según el sistema operativo
function normalizePath(inputPath, targetOS) {
  let normalizedPath = inputPath.replace(/\\/g, "/");
  if (targetOS === "windows") {
    normalizedPath = normalizedPath.replace(/\//g, "\\");
  }
  return normalizedPath;
}
// Función para unir directorio y nombre de archivo
function joinPath(directoryPath, filename, targetOS) {
  const normalizedDirectoryPath = normalizePath(directoryPath, targetOS);
  const joinedPath = path.join(normalizedDirectoryPath, filename);
  const normalizedPath = normalizePath(joinedPath, targetOS);

  //console.log(`Original Directory Path: ${directoryPath}`);
  //console.log(`Filename: ${filename}`);
  //console.log(`Joined Path: ${joinedPath}`);
  //console.log(`Normalized Path: ${normalizedPath}`);

  return normalizedPath;
}
// Configuración de conexión a la base de datos
const dbConfig = {
  user: "USRMONBK",
  password: "USRMONBK_2024",
  connectString: "10.0.211.58:1521/MONBKPDB.cmac-arequipa.com.pe",
};
// Crea una ventana de aplicación
function createWindow() {
  const mainWindow = new BrowserWindow({
    webPreferences: {
      preload: path.join(__dirname, "preload.js"),
      contextIsolation: true,
      enableRemoteModule: false,
      nodeIntegration: false,
    },
  });

  mainWindow.maximize(); // Maximiza la ventana
  mainWindow.loadFile("index.html");
}

app.whenReady().then(() => {
  createWindow();
  ipcMain.handle(
    "connect-to-server",
    async (event, { ip, port, username, password }) => {
      console.log(
        `Attempting to connect to ${ip}:${port} with username ${username}`
      );
      const isConnected = await checkConnection(ip, port, username, password);
      return isConnected;
    }
  );
  function executeSSHCommand(conn, command) {
    return new Promise((resolve, reject) => {
      conn.exec(command, (err, stream) => {
        if (err) return reject(err);

        let output = "";
        stream
          .on("data", (data) => {
            output += data.toString();
          })
          .on("close", (code, signal) => {
            resolve(output); // Resolvemos la promesa con el resultado del comando
          })
          .on("error", (err) => {
            reject(err);
          });
      });
    });
  }

  ipcMain.handle(
    "get-log-details",
    async (
      event,
      { directoryPath, ip, port, username, password, targetOS }
    ) => {
      return await getLogDetailsLogic(
        directoryPath,
        ip,
        port,
        username,
        password,
        targetOS
      );
    }
  );
  // Función que encapsula la lógica de get-log-details
  async function getLogDetailsLogic(
    directoryPath,
    ip,
    port,
    username,
    password,
    targetOS
  ) {
    let allLogDetails = [];
    // Obtener el nombre del servidor
    const servers = await getServers(); // Usa la función que ya tienes
    const server = servers.find((s) => s.ip === ip);
    const serverName = server ? server.name : "N/A";

    try {
      console.log(`Fetching log details from directory: ${directoryPath}`);

      // Initialize SSH connection
      const conn = await createSSHClient(ip, port, username, password);
      // Initialize SFTP connection
      const sftp = await new Promise((resolve, reject) => {
        conn.sftp((err, sftp) => {
          if (err) {
            console.error("SFTP error:", err);
            conn.end();
            return reject(new Error(`SFTP error: ${err.message}`));
          }
          resolve(sftp);
        });
      });
      // Llamada a getFolderSize para Solaris, Linux, y Windows
      const folderSizes = await getFolderSize(
        conn,
        directoryPath,
        targetOS,
        sftp
      );
      console.log("Tamaños de las subcarpetas:", folderSizes);

      if (targetOS === "solaris") {
        // Asegurarse de que folderSizes sea un arreglo solo para Solaris
        if (!Array.isArray(folderSizes)) {
          throw new Error("folderSizes no es un arreglo válido para Solaris.");
        }

        const files = await new Promise((resolve, reject) => {
          sftp.readdir(directoryPath, (err, files) => {
            if (err) {
              console.error("Readdir error:", err);
              sftp.end();
              conn.end();
              return reject(
                new Error(`Failed to read directory: ${err.message}`)
              );
            }
            resolve(files);
          });
        });

        for (const file of files) {
          if (file.attrs.isDirectory()) {
            const subDirPath = joinPath(directoryPath, file.filename, targetOS);

            console.log(`Processing subdirectory: ${subDirPath}`);

            const subDirFiles = await new Promise((resolve, reject) => {
              sftp.readdir(subDirPath, (err, files) => {
                if (err) {
                  console.error("Readdir error:", err);
                  sftp.end();
                  conn.end();
                  return reject(
                    new Error(`Failed to read subdirectory: ${err.message}`)
                  );
                }
                resolve(files);
              });
            });
            // Encuentra el tamaño del subdirectorio directamente desde folderSizes sin realizar comparaciones
            const folderSizeInfo = folderSizes.find((folder) =>
              folder.folderPath.includes(file.filename)
            );
            const totalFolderSize = folderSizeInfo
              ? `${folderSizeInfo.sizeInMB} MB`
              : "N/A";

            console.log(
              "Tamaño total de la carpeta (totalFolderSize):",
              totalFolderSize
            );

            const logFiles = subDirFiles.filter(
              (file) => path.extname(file.filename) === ".log"
            );

            let dumpFileInfo = []; // Reinicia para cada subdirectorio
            let totalDmpSize = 0; // Reinicia para cada subdirectorio
            let logDetails = null;
            let logFileName = null;

            for (const logFile of logFiles) {
              logFileName = logFile.filename;
              const logFilePath = joinPath(subDirPath, logFileName, targetOS);

              console.log("Attempting to read log file:", logFilePath);

              await new Promise((resolve, reject) => {
                sftp.stat(logFilePath, (err, stats) => {
                  if (err) {
                    console.error("Stat error:", err);
                    sftp.end();
                    conn.end();
                    return reject(
                      new Error(`Failed to stat log file: ${err.message}`)
                    );
                  }
                  resolve(stats);
                });
              });

              const logData = await new Promise((resolve, reject) => {
                sftp.readFile(logFilePath, "utf8", (err, data) => {
                  if (err) {
                    console.error("ReadFile error:", err);
                    sftp.end();
                    conn.end();
                    return reject(
                      new Error(`Failed to read log file: ${err.message}`)
                    );
                  }
                  resolve(data);
                });
              });

              logDetails = parseLogLine(logData);

              const dumpFiles = subDirFiles.filter((file) =>
                [".DMP", ".dmp"].includes(
                  path.extname(file.filename).toUpperCase()
                )
              );

              for (const dumpFile of dumpFiles) {
                const dumpFilePath = joinPath(
                  subDirPath,
                  dumpFile.filename,
                  targetOS
                );

                const dumpStats = await new Promise((resolve, reject) => {
                  sftp.stat(dumpFilePath, (err, stats) => {
                    if (err) {
                      console.error("Stat error:", err);
                      sftp.end();
                      conn.end();
                      return reject(
                        new Error(`Failed to stat dump file: ${err.message}`)
                      );
                    }
                    resolve(stats);
                  });
                });

                const dumpFileSizeInMB = dumpStats.size / (1024 * 1024);
                totalDmpSize += dumpFileSizeInMB;

                dumpFileInfo.push({
                  filePath: dumpFilePath,
                  fileSize:
                    dumpFileSizeInMB > 0
                      ? parseFloat(dumpFileSizeInMB.toFixed(2))
                      : 0,
                });
              }
            }

            allLogDetails.push({
              logDetails,
              dumpFileInfo,
              logFileName,
              ip,
              backupPath: subDirPath,
              os: targetOS,
              totalDmpSize: totalDmpSize > 0 ? totalDmpSize.toFixed(2) : 0,
              totalFolderSize,
              serverName: serverName,
            });
            // Añade este log para verificar el valor
            console.log(
              "Tamaño de la carpeta (totalFolderSize):",
              totalFolderSize
            );
          }
        }
        return allLogDetails;
      } else {
        if (typeof folderSizes !== "number") {
          throw new Error("folderSizes debe ser un número para Linux/Windows.");
        }
        // Logic for other OS (Windows, Linux)
        const files = await new Promise((resolve, reject) => {
          sftp.readdir(directoryPath, (err, files) => {
            if (err) {
              console.error("Readdir error:", err);
              sftp.end();
              conn.end();
              return reject(
                new Error(`Failed to read directory: ${err.message}`)
              );
            }
            resolve(files);
          });
        });

        // Check if there are subdirectories
        const subdirectories = files.filter((file) => file.attrs.isDirectory());

        if (subdirectories.length > 0) {
          // Process each subdirectory
          let allSubdirResults = [];
          for (const subdir of subdirectories) {
            const subDirPath = joinPath(
              directoryPath,
              subdir.filename,
              targetOS
            );

            // Read subdirectory contents
            const subDirFiles = await new Promise((resolve, reject) => {
              sftp.readdir(subDirPath, (err, files) => {
                if (err) {
                  console.error("Readdir error:", err);
                  return reject(
                    new Error(`Failed to read subdirectory: ${err.message}`)
                  );
                }
                resolve(files);
              });
            });

            // Process log files in subdirectory
            const logFiles = subDirFiles.filter(
              (file) => path.extname(file.filename) === ".log"
            );

            if (logFiles.length > 0) {
              const latestLogFile = logFiles.reduce((latest, file) =>
                file.attrs.mtime > latest.attrs.mtime ? file : latest
              );
              let logFileName = latestLogFile.filename;
              const logFilePath = joinPath(subDirPath, logFileName, targetOS);

              console.log("Attempting to read log file:", logFilePath);

              await new Promise((resolve, reject) => {
                sftp.stat(logFilePath, (err, stats) => {
                  if (err) {
                    console.error("Stat error:", err);
                    sftp.end();
                    conn.end();
                    return reject(
                      new Error(`Failed to stat log file: ${err.message}`)
                    );
                  }
                  resolve(stats);
                });
              });

              const logData = await new Promise((resolve, reject) => {
                sftp.readFile(logFilePath, "utf8", (err, data) => {
                  if (err) {
                    console.error("ReadFile error:", err);
                    sftp.end();
                    conn.end();
                    return reject(
                      new Error(`Failed to read log file: ${err.message}`)
                    );
                  }
                  resolve(data);
                });
              });

              const logDetails = parseLogLine(logData);
              let dumpFileInfo = [];
              const dumpFiles = subDirFiles.filter((file) =>
                [".DMP", ".dmp"].includes(
                  path.extname(file.filename).toUpperCase()
                )
              );

              let totalDmpSize = 0;
              for (const dumpFile of dumpFiles) {
                const dumpFilePath = joinPath(
                  subDirPath,
                  dumpFile.filename,
                  targetOS
                );

                const dumpStats = await new Promise((resolve, reject) => {
                  sftp.stat(dumpFilePath, (err, stats) => {
                    if (err) {
                      console.error("Stat error:", err);
                      sftp.end();
                      conn.end();
                      return reject(
                        new Error(`Failed to stat dump file: ${err.message}`)
                      );
                    }
                    resolve(stats);
                  });
                });

                const dumpFileSizeInMB = dumpStats.size / (1024 * 1024);
                totalDmpSize += dumpFileSizeInMB;

                dumpFileInfo.push({
                  filePath: dumpFilePath,
                  fileSize:
                    dumpFileSizeInMB > 0
                      ? parseFloat(dumpFileSizeInMB.toFixed(2))
                      : 0,
                });
              }

              allSubdirResults.push({
                logDetails,
                dumpFileInfo,
                logFileName,
                ip,
                backupPath: subDirPath,
                os: targetOS,
                totalDmpSize: totalDmpSize > 0 ? totalDmpSize.toFixed(2) : 0,
                totalFolderSize: `${folderSizes} MB`,
                serverName: serverName,
              });
            }
          }
          return allSubdirResults;
        } else {
          // No subdirectories, process the main directory
          const logFiles = files.filter(
            (file) => path.extname(file.filename) === ".log"
          );

          if (logFiles.length > 0) {
            const latestLogFile = logFiles.reduce((latest, file) =>
              file.attrs.mtime > latest.attrs.mtime ? file : latest
            );
            let logFileName = latestLogFile.filename;
            const logFilePath = joinPath(directoryPath, logFileName, targetOS);

            console.log("Attempting to read log file:", logFilePath);

            await new Promise((resolve, reject) => {
              sftp.stat(logFilePath, (err, stats) => {
                if (err) {
                  console.error("Stat error:", err);
                  sftp.end();
                  conn.end();
                  return reject(
                    new Error(`Failed to stat log file: ${err.message}`)
                  );
                }
                resolve(stats);
              });
            });

            const logData = await new Promise((resolve, reject) => {
              sftp.readFile(logFilePath, "utf8", (err, data) => {
                if (err) {
                  console.error("ReadFile error:", err);
                  sftp.end();
                  conn.end();
                  return reject(
                    new Error(`Failed to read log file: ${err.message}`)
                  );
                }
                resolve(data);
              });
            });

            const logDetails = parseLogLine(logData);
            let dumpFileInfo = [];
            const dumpFiles = files.filter((file) =>
              [".DMP", ".dmp"].includes(
                path.extname(file.filename).toUpperCase()
              )
            );

            let totalDmpSize = 0;
            for (const dumpFile of dumpFiles) {
              const dumpFilePath = joinPath(
                directoryPath,
                dumpFile.filename,
                targetOS
              );

              const dumpStats = await new Promise((resolve, reject) => {
                sftp.stat(dumpFilePath, (err, stats) => {
                  if (err) {
                    console.error("Stat error:", err);
                    sftp.end();
                    conn.end();
                    return reject(
                      new Error(`Failed to stat dump file: ${err.message}`)
                    );
                  }
                  resolve(stats);
                });
              });

              const dumpFileSizeInMB = dumpStats.size / (1024 * 1024);
              totalDmpSize += dumpFileSizeInMB;

              dumpFileInfo.push({
                filePath: dumpFilePath,
                fileSize:
                  dumpFileSizeInMB > 0
                    ? parseFloat(dumpFileSizeInMB.toFixed(2))
                    : 0,
              });
            }

            return [
              {
                logDetails,
                dumpFileInfo,
                logFileName,
                ip,
                backupPath: directoryPath,
                os: targetOS,
                totalDmpSize: totalDmpSize > 0 ? totalDmpSize.toFixed(2) : 0,
                totalFolderSize: `${folderSizes} MB`,
                serverName: serverName,
              },
            ];
          }
        }

        sftp.end();
        conn.end();
      }
    } catch (error) {
      console.error("Error fetching log details:", error);
      return { logDetails: null, dumpFileInfo: null };
    }
  }

  // Clave de encriptación (debe ser segura y almacenada en un lugar seguro)
  // Clave de encriptación (debe ser segura y almacenada en un lugar seguro)
  const encryptionKey = Buffer.from(
    "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
    "hex"
  );
  const iv = Buffer.from("abcdef0123456789abcdef0123456789", "hex");

  // Función para encriptar
  function encrypt(text) {
    let cipher = crypto.createCipheriv(
      "aes-256-cbc",
      Buffer.from(encryptionKey),
      iv
    );
    let encrypted = cipher.update(text);
    encrypted = Buffer.concat([encrypted, cipher.final()]);
    return { iv: iv.toString("hex"), encryptedData: encrypted.toString("hex") };
  }

  // Conexión a la base de datos y función para insertar servidor
  async function insertServerInfo(
    ip,
    osType,
    port,
    encryptedUser,
    encryptedPassword,
    serverName
  ) {
    let connection;

    try {
      connection = await oracledb.getConnection({
        user: "USRMONBK",
        password: "USRMONBK_2024",
        connectString: "10.0.211.58:1521/MONBKPDB.cmac-arequipa.com.pe",
      });

      // Insertar datos en la base de datos, incluyendo un ID definido
      const result = await connection.execute(
        `INSERT INTO ServerInfo (IP, OS_Type, Port, EncryptedUser, EncryptedPassword, ServerName)
       VALUES (:ip, :osType, :port, :encryptedUser, :encryptedPassword, :serverName)`,
        {
          ip: ip,
          osType: osType,
          port: port,
          encryptedUser: Buffer.from(JSON.stringify(encryptedUser)),
          encryptedPassword: Buffer.from(JSON.stringify(encryptedPassword)),
          serverName: serverName,
        },
        { autoCommit: true }
      );

      console.log("Servidor insertado correctamente:", result);
    } catch (err) {
      console.error("Error al insertar servidor en la base de datos:", err);
      throw err;
    } finally {
      if (connection) {
        try {
          await connection.close();
        } catch (err) {
          console.error("Error al cerrar la conexión a la base de datos:", err);
        }
      }
    }
  }

  // Modificación en el manejo del IPC para agregar un servidor con ID
  ipcMain.handle("add-server", async (event, serverData) => {
    const { serverName, ip, os, port, username, password } = serverData;

    try {
      console.log(`Agregando servidor: ${serverName}, IP: ${ip}, OS: ${os}`);
      const encryptedUser = encrypt(username);
      const encryptedPassword = encrypt(password);

      // Pasamos el ID manualmente al insertar el servidor
      await insertServerInfo(
        ip,
        os,
        port,
        encryptedUser,
        encryptedPassword,
        serverName
      );
      return { success: true };
    } catch (error) {
      console.error("Error al agregar el servidor:", error);
      return { success: false, error: error.message };
    }
  });

  ipcMain.handle(
    "save-log-to-database",
    async (
      event,
      { logDetails, dumpFileInfo, targetOS, logFileName, ip, backupPath }
    ) => {
      try {
        await saveLogToDatabase(
          logDetails,
          dumpFileInfo,
          targetOS,
          logFileName,
          ip,
          backupPath
        );
        return { success: true };
      } catch (error) {
        console.error("Error saving log details to database:", error);
        throw error;
      }
    }
  );

  async function getServers() {
    let connection;
    try {
      connection = await oracledb.getConnection({
        user: "USRMONBK",
        password: "USRMONBK_2024",
        connectString: "10.0.211.58:1521/MONBKPDB.cmac-arequipa.com.pe",
      });

      const result = await connection.execute(
        `SELECT ID, ServerName, IP, OS_Type, Port FROM ServerInfo`
      );
      return result.rows.map((row) => ({
        id: row[0],
        name: row[1],
        ip: row[2],
        os: row[3],
        port: row[4],
      }));
    } catch (err) {
      console.error("Error al recuperar datos de la base de datos:", err);
      throw err;
    } finally {
      if (connection) {
        try {
          await connection.close();
        } catch (err) {
          console.error("Error al cerrar la conexión a la base de datos:", err);
        }
      }
    }
  }
  ipcMain.handle("get-servers", async () => {
    return await getServers();
  });

  async function readLob(lob) {
    return new Promise((resolve, reject) => {
      let data = [];
      lob.on("data", (chunk) => data.push(chunk));
      lob.on("end", () => resolve(Buffer.concat(data)));
      lob.on("error", (err) => reject(err));
    });
  }

  function decrypt(encryptedData) {
    try {
      // Si encryptedData es un string, intentamos parsearlo como JSON
      if (typeof encryptedData === "string") {
        encryptedData = JSON.parse(encryptedData);
      }

      // Si encryptedData es un objeto Buffer, lo convertimos a string
      if (Buffer.isBuffer(encryptedData)) {
        encryptedData = encryptedData.toString();
      }

      // Ahora parseamos el JSON
      const data = JSON.parse(encryptedData);

      // Verificamos que tenemos los datos necesarios
      if (!data.iv || !data.encryptedData) {
        throw new Error("Formato de datos encriptados inválido");
      }

      let iv = Buffer.from(data.iv, "hex");
      let encryptedText = Buffer.from(data.encryptedData, "hex");
      let decipher = crypto.createDecipheriv("aes-256-cbc", encryptionKey, iv);
      let decrypted = decipher.update(encryptedText);
      decrypted = Buffer.concat([decrypted, decipher.final()]);

      // Convertimos a string y eliminamos comillas adicionales
      let decryptedText = decrypted.toString().replace(/^"|"$/g, "");

      // Intentamos parsear el resultado como JSON
      try {
        return JSON.parse(decryptedText);
      } catch (e) {
        // Si no es JSON válido, devolvemos el string
        return decryptedText;
      }
    } catch (error) {
      console.error("Error al desencriptar:", error);
      return null;
    }
  }

  ipcMain.handle("get-server-details", async (event, serverId) => {
    let connection;
    try {
      connection = await oracledb.getConnection(dbConfig);

      const result = await connection.execute(
        `SELECT ID, ServerName, IP, OS_Type, Port, EncryptedUser, EncryptedPassword 
         FROM ServerInfo WHERE ID = :id`,
        { id: serverId }
      );

      if (result.rows.length > 0) {
        const row = result.rows[0];
        const encryptedUserLob = row[5]; // EncryptedUser LOB
        const encryptedPasswordLob = row[6]; // EncryptedPassword LOB

        // Leer los LOBs de usuario y contraseña
        const encryptedUser = await readLob(encryptedUserLob);
        const encryptedPassword = await readLob(encryptedPasswordLob);

        // Aquí verificamos si ya está en texto claro
        let decryptedUser = encryptedUser.toString();
        let decryptedPassword = encryptedPassword.toString();

        // Verificamos si los valores están en texto claro o si necesitan desencriptarse
        if (
          decryptedUser.startsWith("{") &&
          decryptedUser.includes("encryptedData")
        ) {
          decryptedUser = decrypt(encryptedUser); // Desencripta solo si es necesario
        }

        if (
          decryptedPassword.startsWith("{") &&
          decryptedPassword.includes("encryptedData")
        ) {
          decryptedPassword = decrypt(encryptedPassword); // Desencripta solo si es necesario
        }

        console.log("Decrypted User:", decryptedUser); // Agregar este log
        console.log("Decrypted Password:", decryptedPassword); // Agregar este log

        return {
          id: row[0],
          serverName: row[1],
          ip: row[2],
          os: row[3],
          port: row[4],
          username: decryptedUser, // Usuario desencriptado o en texto claro
          password: decryptedPassword, // Contraseña desencriptada o en texto claro
        };
      } else {
        return { error: "Servidor no encontrado" };
      }
    } catch (err) {
      console.error("Error al obtener los detalles del servidor:", err);
      return { error: err.message };
    } finally {
      if (connection) {
        try {
          await connection.close();
        } catch (err) {
          console.error("Error al cerrar la conexión:", err);
        }
      }
    }
  });

  ipcMain.handle("delete-server", async (event, serverId) => {
    let connection;
    try {
      // Establecer conexión a la base de datos
      connection = await oracledb.getConnection({
        user: "USRMONBK",
        password: "USRMONBK_2024",
        connectString: "10.0.211.58:1521/MONBKPDB.cmac-arequipa.com.pe",
      });

      // Ejecutar la consulta de eliminación
      const result = await connection.execute(
        `DELETE FROM ServerInfo WHERE ID = :id`,
        { id: serverId },
        { autoCommit: true }
      );

      console.log(`Servidor con ID ${serverId} eliminado.`, result);

      // Verificar si se eliminó algún registro
      if (result.rowsAffected === 0) {
        return {
          success: false,
          error: `No se encontró el servidor con ID ${serverId}`,
        };
      }

      return { success: true };
    } catch (err) {
      console.error("Error al eliminar el servidor:", err);
      return { success: false, error: err.message };
    } finally {
      // Cerrar la conexión
      if (connection) {
        try {
          await connection.close();
        } catch (err) {
          console.error("Error al cerrar la conexión:", err);
        }
      }
    }
  });

  ipcMain.handle(
    "verify-credentials", //ACA ESTA DESENCRIPTADO
    async (event, { ip, username, password }) => {
      let connection;

      try {
        connection = await oracledb.getConnection(dbConfig);

        const result = await connection.execute(
          `SELECT EncryptedUser, EncryptedPassword, OS_Type, Port FROM ServerInfo WHERE IP = :ip`,
          { ip: ip }
        );

        if (result.rows.length > 0) {
          const encryptedUserLob = result.rows[0][0];
          const encryptedPasswordLob = result.rows[0][1];
          const osType = result.rows[0][2];
          const port = result.rows[0][3];

          if (!encryptedUserLob || !encryptedPasswordLob) {
            throw new Error("Encrypted User or Password Lob is undefined");
          }

          // Leer los Lobs
          const encryptedUser = await readLob(encryptedUserLob);
          const encryptedPassword = await readLob(encryptedPasswordLob);

          //console.log("Encrypted User Buffer:", encryptedUser);
          //console.log("Encrypted Password Buffer:", encryptedPassword);

          if (!encryptedUser || !encryptedPassword) {
            throw new Error("Failed to read Lob data");
          }

          // Desencriptar los datos
          let storedUser, storedPassword;
          try {
            storedUser = decrypt(encryptedUser);
            storedPassword = decrypt(encryptedPassword);
          } catch (decryptionError) {
            console.error("Error al desencriptar los datos:", decryptionError);
            return {
              success: false,
              message: "Error al desencriptar los datos.",
            };
          }

          // Comparar las credenciales
          if (storedUser === username && storedPassword === password) {
            return { success: true, osType, port };
          } else {
            return {
              success: false,
              message: "Usuario o contraseña incorrectos.",
            };
          }
        } else {
          return { success: false, message: "Servidor no encontrado." };
        }
      } catch (err) {
        console.error("Error al verificar las credenciales:", err);
        return {
          success: false,
          message: "Error en la verificación de credenciales.",
        };
      } finally {
        if (connection) {
          try {
            await connection.close();
          } catch (err) {
            console.error(
              "Error al cerrar la conexión a la base de datos:",
              err
            );
          }
        }
      }
    }
  );
  // Función para actualizar servidor en la base de datos
  async function updateServerInfo(id, name, ip, os, port, username, password) {
    let connection;

    try {
      connection = await oracledb.getConnection({
        user: "USRMONBK",
        password: "USRMONBK_2024",
        connectString: "10.0.211.58:1521/MONBKPDB.cmac-arequipa.com.pe",
      });

      // Actualizar datos del servidor
      const result = await connection.execute(
        `UPDATE ServerInfo 
       SET ServerName = :name, IP = :ip, OS_Type = :os, Port = :port, EncryptedUser = :username, EncryptedPassword = :password
       WHERE ID = :id`,
        {
          id: id,
          name: name,
          ip: ip,
          os: os,
          port: port,
          username: Buffer.from(JSON.stringify(username)), // Encripta el usuario
          password: Buffer.from(JSON.stringify(password)), // Encripta la contraseña
        },
        { autoCommit: true }
      );

      console.log("Servidor actualizado correctamente:", result);
      return result;
    } catch (err) {
      console.error("Error al actualizar servidor en la base de datos:", err);
      throw err;
    } finally {
      if (connection) {
        try {
          await connection.close();
        } catch (err) {
          console.error("Error al cerrar la conexión a la base de datos:", err);
        }
      }
    }
  }

  // En el IPC handle para editar el servidor
  // En el manejador para actualizar el servidor
  ipcMain.handle("update-server", async (event, serverData) => {
    const { id, serverName, ip, os, port, username, password } = serverData;

    try {
      console.log(`Actualizando servidor: ${serverName}, IP: ${ip}, OS: ${os}`);

      // Eliminar comillas innecesarias en el username y password antes de encriptarlos
      const cleanUsername = username.replace(/^"|"$/g, "");
      const cleanPassword = password.replace(/^"|"$/g, "");

      const encryptedUser = encrypt(cleanUsername); // Encripta el usuario limpio
      const encryptedPassword = encrypt(cleanPassword); // Encripta la contraseña limpia

      const result = await updateServerInfo(
        id,
        serverName,
        ip,
        os,
        port,
        encryptedUser,
        encryptedPassword
      );
      console.log("Servidor actualizado correctamente:", result);

      return { success: true };
    } catch (error) {
      console.error("Error al actualizar el servidor:", error);
      return { success: false, error: error.message };
    }
  });
  ipcMain.handle("getBackupRoutesByIP", async (event, ip) => {
    console.log("IP recibida para obtener rutas:", ip);
    let connection;
    try {
      connection = await oracledb.getConnection(dbConfig);

      const result = await connection.execute(
        `SELECT br.BackupPath, si.OS_Type 
       FROM BackupRoutes br 
       JOIN ServerInfo si ON br.ServerID = si.ID 
       WHERE si.IP = :ip`,
        { ip: ip }
      );

      console.log("Rutas obtenidas de la base de datos:", result.rows); // Añadir log

      return result.rows.map((row) => ({
        backupPath: row[0],
        os: row[1],
      }));
    } catch (error) {
      console.error("Error al obtener las rutas de backup:", error);
      return [];
    } finally {
      if (connection) {
        try {
          await connection.close();
        } catch (err) {
          console.error("Error al cerrar la conexión:", err);
        }
      }
    }
  });
  async function getAllServers() {
    let connection;
    try {
      connection = await oracledb.getConnection(dbConfig);
      const result = await connection.execute(
        `SELECT ID, ServerName, IP, OS_Type, Port, EncryptedUser, EncryptedPassword 
         FROM ServerInfo`,
        [],
        {
          fetchInfo: {
            EncryptedUser: { type: oracledb.STRING },
            EncryptedPassword: { type: oracledb.STRING },
          },
        }
      );

      return result.rows.map((row) => ({
        id: row[0],
        serverName: row[1],
        ip: row[2],
        os: row[3],
        port: row[4],
        encryptedUser: row[5],
        encryptedPassword: row[6],
      }));
    } catch (err) {
      console.error("Error al obtener los servidores:", err);
      throw err;
    } finally {
      if (connection) {
        try {
          await connection.close();
        } catch (err) {
          console.error("Error al cerrar la conexión:", err);
        }
      }
    }
  }
  // Añade esta función para usar dentro de processAllServers
  async function getBackupRoutesByIPInternal(ip, connection) {
    try {
      const result = await connection.execute(
        `SELECT br.BackupPath, si.OS_Type
       FROM BackupRoutes br
       JOIN ServerInfo si ON br.ServerID = si.ID
       WHERE si.IP = :ip`,
        { ip: ip }
      );

      console.log("Rutas obtenidas de la base de datos:", result.rows);

      return result.rows.map((row) => ({
        backupPath: row[0],
        os: row[1],
      }));
    } catch (error) {
      console.error("Error al obtener las rutas de backup:", error);
      return [];
    }
  }

  async function processAllServers() {
    let connection;
    let results = [];

    try {
      connection = await oracledb.getConnection(dbConfig);

      const serversResult = await connection.execute(
        `SELECT ID, ServerName, IP, OS_Type, Port, EncryptedUser, EncryptedPassword FROM ServerInfo`
      );

      for (const row of serversResult.rows) {
        const serverName = row[1];
        const ip = row[2];
        const osType = row[3];
        const port = row[4];
        const encryptedUserLob = row[5];
        const encryptedPasswordLob = row[6];

        try {
          console.log(`Procesando servidor: ${serverName} (${ip})`);

          // Desencriptar credenciales
          const decryptedUser = await decrypt(await readLob(encryptedUserLob));
          const decryptedPassword = await decrypt(
            await readLob(encryptedPasswordLob)
          );

          console.log(`Credenciales desencriptadas para ${serverName}`);

          // Obtener rutas de backup
          const backupRoutes = await getBackupRoutesByIPInternal(
            ip,
            connection
          );
          console.log(
            `Rutas de backup obtenidas para ${serverName}:`,
            backupRoutes
          );

          const backupPath = backupRoutes[0]?.backupPath;

          if (!backupPath) {
            throw new Error(
              `No se encontró ruta de backup para el servidor ${serverName}`
            );
          }

          console.log(
            `Obteniendo detalles de log para ${serverName} desde ${backupPath}`
          );

          // Usar ipcRenderer para invocar get-log-details
          const logDetails = await getLogDetailsLogic(
            backupPath,
            ip,
            port,
            decryptedUser,
            decryptedPassword,
            osType
          );

          console.log(
            `Detalles de log obtenidos para ${serverName}:`,
            logDetails
          );

          if (
            !logDetails ||
            (Array.isArray(logDetails) && logDetails.length === 0)
          ) {
            console.log(`No se encontraron detalles de log para ${serverName}`);
            results.push({
              serverName,
              ip,
              error: "No se encontraron detalles de log",
            });
            continue;
          }

          // Guardar los detalles en la base de datos
          if (Array.isArray(logDetails)) {
            for (const detail of logDetails) {
              await saveLogToDatabase(
                detail.logDetails,
                detail.dumpFileInfo,
                osType,
                detail.logFileName,
                ip,
                backupPath
              );
            }
          } else if (logDetails && logDetails.logDetails) {
            await saveLogToDatabase(
              logDetails.logDetails,
              logDetails.dumpFileInfo,
              osType,
              logDetails.logFileName,
              ip,
              backupPath
            );
          }

          results.push({
            serverName,
            ip,
            logDetails,
          });
        } catch (error) {
          console.error(`Error procesando el servidor ${serverName}:`, error);
          results.push({
            serverName,
            ip,
            error: error.message,
          });
        }
      }
    } catch (err) {
      console.error("Error al procesar todos los servidores:", err);
    } finally {
      if (connection) {
        try {
          await connection.close();
        } catch (err) {
          console.error("Error al cerrar la conexión a la base de datos:", err);
        }
      }
    }

    return results;
  }
  ipcMain.handle("process-all-servers", async (event) => {
    try {
      const results = await processAllServers();
      return { success: true, results };
    } catch (error) {
      console.error("Error al procesar todos los servidores:", error);
      return { success: false, error: error.message };
    }
  });

  async function getFolderSize(conn, directoryPath, os, sftp) {
    if (os === "solaris") {
      // Lógica para Solaris: Usar `du` para obtener el tamaño de todas las subcarpetas en un solo comando
      const command = `du -sk ${directoryPath}/* | awk '{print $1/1024, $2}'`; // Cambiamos aquí el awk para que no incluya "MB"
      const output = await executeSSHCommand(conn, command);
      console.log("Salida del comando du:", output);

      if (!output || output.trim() === "") {
        throw new Error("No se obtuvo salida del comando du");
      }

      // Aquí ajustamos cómo se parsea la salida del comando `du`
      return output
        .trim()
        .split("\n")
        .map((line) => {
          const parts = line.split(/\s+/); // Separar por cualquier espacio en blanco
          const sizeInMB = parts[0]; // El primer valor es el tamaño
          const folderPath = parts.slice(1).join(" "); // El resto es el folder path completo
          return {
            folderPath: folderPath.trim(), // Asegurarse de eliminar espacios en blanco
            sizeInMB: parseFloat(sizeInMB).toFixed(2), // Formatear el tamaño a dos decimales
          };
        });
    } else {
      // Nueva lógica para Windows y Linux
      async function calculateSize(path) {
        let totalSize = 0;
        const files = await new Promise((resolve, reject) => {
          sftp.readdir(path, (err, fileList) => {
            if (err) return reject(err);
            resolve(fileList || []);
          });
        });

        for (const file of files) {
          const filePath =
            path + (os === "windows" ? "\\" : "/") + file.filename;
          const stats = await new Promise((resolve, reject) => {
            sftp.stat(filePath, (err, stats) => {
              if (err) return reject(err);
              resolve(stats);
            });
          });

          if (stats.isDirectory()) {
            totalSize += await calculateSize(filePath);
          } else {
            totalSize += stats.size;
          }
        }

        return totalSize;
      }

      const totalSize = await calculateSize(directoryPath);
      return parseFloat((totalSize / (1024 * 1024)).toFixed(2)); // Tamaño en MB
    }
  }
  app.on("activate", () => {
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow();
    }
  });
});
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

function createSSHClient(ip, port, username, password) {
  return new Promise((resolve, reject) => {
    const conn = new Client();

    conn
      .on("ready", () => {
        console.log("SSH Connection established");
        resolve(conn);
      })
      .on("error", (err) => {
        reject(new Error(`SSH Connection failed: ${err.message}`));
      })
      .connect({
        host: ip,
        port: port,
        username: username,
        password: password,
        algorithms: {
          kex: ["diffie-hellman-group14-sha1", "diffie-hellman-group14-sha256"],
          cipher: ["aes128-ctr", "aes192-ctr", "aes256-ctr"],
          hmac: ["hmac-sha1", "hmac-sha2-256", "hmac-sha2-512"],
        },
      });
  });
}

function checkConnection(ip, port, username, password) {
  return new Promise((resolve, reject) => {
    const conn = new Client();

    conn
      .on("ready", () => {
        console.log("Initial connection successful");
        conn.exec('echo "Connection test"', (err, stream) => {
          if (err) {
            console.error("Exec error:", err);
            conn.end();
            reject(new Error(`Exec failed: ${err.message}`));
          }
          stream
            .on("close", (code, signal) => {
              conn.end();
              resolve(true);
            })
            .on("data", (data) => {
              console.log("Received:", data.toString());
            })
            .stderr.on("data", (data) => {
              console.error("STDERR:", data.toString());
            });
        });
      })
      .on("error", (err) => {
        resolve(false);
      })
      .connect({
        host: ip,
        port: port,
        username: username,
        password: password,
        algorithms: {
          kex: ["diffie-hellman-group14-sha1", "diffie-hellman-group14-sha256"],
          cipher: ["aes128-ctr", "aes192-ctr", "aes256-ctr"],
          hmac: ["hmac-sha1", "hmac-sha2-256", "hmac-sha2-512"],
        },
      });
  });
}

// Función para parsear las fechas en el log y formatearlas para Oracle
function formatDateForOracle(date) {
  if (!date) return null;

  const dateObj = new Date(date);
  if (isNaN(dateObj.getTime())) {
    console.error("Invalid date:", date);
    return null;
  }

  return dateObj
    .toLocaleString("en-US", {
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      hour12: false,
    })
    .replace(/(\d+)\/(\d+)\/(\d+),/, "$3-$1-$2");
}

function parseLogLine(logContent) {
  const oraErrorPattern = /ORA-\d{5}/g;
  const oraSpecificErrorPattern = /ORA-39327/;
  const successPattern = /successfully completed/i;

  const lines = logContent.split("\n");
  let lastLine = lines[lines.length - 1].trim();

  // Si la última línea está vacía, busca la primera línea no vacía desde el final
  while (lastLine === "" && lines.length > 1) {
    lines.pop(); // Elimina la última línea vacía
    lastLine = lines[lines.length - 1].trim();
  }

  console.log("Last line of log after handling empty lines:", lastLine); // Depuración

  let backupStatus = "EN PROGRESO"; // Estado por defecto

  if (lastLine.toLowerCase().includes("completed")) {
    backupStatus = "COMPLETED"; // Siempre establecer a "COMPLETED"
  }

  const hasOraSpecificError = oraSpecificErrorPattern.test(logContent);
  const hasSuccessMessage = successPattern.test(logContent);

  const isSuccess = hasOraSpecificError || hasSuccessMessage;

  const datePattern = /(\w{3} \w{3} \d{1,2} \d{2}:\d{2}:\d{2} \d{4})/g;
  const datesMatch = logContent.match(datePattern);

  let startDateTime = null;
  let endDateTime = null;

  if (datesMatch) {
    if (datesMatch.length > 0) {
      startDateTime = new Date(datesMatch[0]);
    }
    if (datesMatch.length > 1) {
      endDateTime = new Date(datesMatch[datesMatch.length - 1]);
    }
  }

  const durationPattern = /elapsed (\d{1,2} \d{2}:\d{2}:\d{2})/;
  const durationMatch = logContent.match(durationPattern);
  let duration = durationMatch ? durationMatch[1] : "N/A";

  // Elimina el "0 " si la duración comienza con "0 "
  if (duration.startsWith("0 ")) {
    duration = duration.substring(2); // Elimina los primeros dos caracteres "0 "
  }

  //console.log("Extracted Data:", { startDateTime, endDateTime, duration });
  let oraError = null;
  for (let i = 0; i < lines.length; i++) {
    if (
      lines[i].match(oraErrorPattern) &&
      !lines[i].match(oraSpecificErrorPattern)
    ) {
      oraError = {
        previousLine: i > 0 ? lines[i - 1].trim() : "",
        errorLine: lines[i].trim(),
        nextLine: i < lines.length - 1 ? lines[i + 1].trim() : "",
      };
      break;
    }
  }
  console.log("Last line of log:", lastLine);
  console.log("Parsed backup status:", backupStatus);
  return {
    startTime: startDateTime ? formatDateForOracle(startDateTime) : null,
    endTime: endDateTime ? formatDateForOracle(endDateTime) : null,
    duration: duration !== "N/A" ? duration : null,
    success: isSuccess ? 1 : 0,
    oraError: oraError,
    backupStatus: backupStatus,
  };
}
function formatFileSize(sizeInMB) {
  if (sizeInMB >= 1000) {
    let sizeInGB = (sizeInMB / 1000).toFixed(2);
    return `${sizeInGB} GB`;
  } else {
    return `${sizeInMB} MB`;
  }
}
async function saveLogToDatabase(
  logDetails,
  dumpFileInfo,
  targetOS,
  logFileName,
  ip,
  backupPath
) {
  let connection;

  try {
    connection = await oracledb.getConnection(dbConfig);

    const startTime = logDetails.startTime
      ? formatDateForOracle(logDetails.startTime)
      : null;
    const endTime = logDetails.endTime
      ? formatDateForOracle(logDetails.endTime)
      : null;

    // Convertir el tamaño de archivo
    let totalDmpSize = 0;
    if (Array.isArray(dumpFileInfo)) {
      dumpFileInfo.forEach((file) => {
        totalDmpSize += parseFloat(file.fileSize) || 0;
      });
    }

    const formattedFileSize = formatFileSize(totalDmpSize); // Convierte a MB o GB

    // Verifica si dumpFileInfo es un array o un solo objeto y suma los tamaños
    if (Array.isArray(dumpFileInfo)) {
      dumpFileInfo.forEach((file) => {
        if (
          file &&
          file.filePath &&
          file.filePath.toLowerCase().endsWith(".dmp")
        ) {
          //console.log(`Found DMP file: ${file.filePath} with size ${file.fileSize}`);
          const fileSize = parseFloat(file.fileSize);
          if (!isNaN(fileSize)) {
            totalDmpSize += fileSize;
          }
        }
      });
    } else if (
      dumpFileInfo &&
      dumpFileInfo.filePath &&
      dumpFileInfo.filePath.toLowerCase().endsWith(".dmp")
    ) {
      console.log(
        `Found single DMP file: ${dumpFileInfo.filePath} with size ${dumpFileInfo.fileSize}`
      );
      const fileSize = parseFloat(dumpFileInfo.fileSize);
      if (!isNaN(fileSize)) {
        totalDmpSize += fileSize;
      }
    } else {
      console.warn(
        "dumpFileInfo is not a valid object or array:",
        dumpFileInfo
      );
    }

    // Convertimos totalDmpSize a un número con dos decimales si es mayor que 0
    const totalDmpSizeFormatted = totalDmpSize > 0 ? totalDmpSize : null;

    //console.log("Valores a insertar:", {
    //horaINI: startTime,
    //horaFIN: endTime,
    //duration: logDetails.duration,
    //success: logDetails.success ? 1 : 0,
    //dumpFileSize: formattedFileSize,
    //serverName: targetOS,
    //logFileName: logFileName,
    //ip: ip,
    //backupPath: backupPath,
    //});

    const result = await connection.execute(
      `INSERT INTO LogBackup (horaINI, duration, success, dumpFileSize, serverName, logFileName, horaFIN, ip, backupPath) 
        VALUES (
          TO_DATE(:horaINI, 'YYYY-MM-DD HH24:MI:SS'),
          :duration,
          :success,
          :fileSize,
          :serverName,
          :logFileName,
          TO_DATE(:horaFIN, 'YYYY-MM-DD HH24:MI:SS'),
          :ip,
          :backupPath
        )`,
      {
        horaINI: startTime,
        horaFIN: endTime,
        duration: logDetails.duration,
        success: logDetails.success ? 1 : 0,
        fileSize: formattedFileSize, // Guardar el valor con la unidad (MB o GB)
        serverName: targetOS,
        logFileName: logFileName,
        ip: ip,
        backupPath: backupPath,
      },
      { autoCommit: true }
    );
    console.log("Detalles del log guardados en la base de datos:", result);
  } catch (err) {
    console.error(
      "Error al guardar los detalles del log en la base de datos:",
      err
    );
    throw err;
  } finally {
    if (connection) {
      try {
        await connection.close();
      } catch (err) {
        console.error("Error al cerrar la conexión con la base de datos:", err);
      }
    }
  }
}

================
File: package.json
================
{
  "name": "backup_1",
  "version": "1.0.0",
  "main": "main.js",
  "scripts": {
    "start": "electron ."
  },
  "pkg": {
    "assets": [
      "node_modules/nanoid/**/*"
    ]
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "basic-ftp": "^5.0.5",
    "crypto": "^1.0.1",
    "docx": "^8.5.0",
    "fs": "^0.0.1-security",
    "node-windows": "^1.0.0-beta.8",
    "node-winrm": "^0.1.3",
    "oracledb": "^6.6.0",
    "rdp": "^1.0.1",
    "ssh2": "^1.15.0",
    "ssh2-sftp-client": "^11.0.0",
    "yargs": "^17.7.2"
  },
  "devDependencies": {
    "electron": "^31.3.1"
  }
}

================
File: preload.js
================
//preload.js
const { contextBridge, ipcRenderer } = require("electron");

contextBridge.exposeInMainWorld("electron", {
  connectToServer: (ip, port, username, password) =>
    ipcRenderer.invoke("connect-to-server", { ip, port, username, password }),

  getLogDetails: (directoryPath, ip, port, username, password, targetOS) =>
    ipcRenderer.invoke("get-log-details", {
      directoryPath,
      ip,
      port,
      username,
      password,
      targetOS,
    }),

  saveLogToDatabase: (
    logDetails,
    dumpFileInfo,
    targetOS,
    logFileName,
    ip,
    backupPath
  ) =>
    ipcRenderer.invoke("save-log-to-database", {
      logDetails,
      dumpFileInfo,
      targetOS,
      logFileName,
      ip,
      backupPath,
    }),

  verifyCredentials: (ip, username, password) =>
    ipcRenderer.invoke("verify-credentials", { ip, username, password }),

  getServers: () => ipcRenderer.invoke("get-servers"),
  addServer: (serverData) => ipcRenderer.invoke("add-server", serverData),
  updateServer: (serverData) => ipcRenderer.invoke("update-server", serverData),
  deleteServer: (serverId) => ipcRenderer.invoke("delete-server", serverId),
  getServerDetails: (id) => ipcRenderer.invoke("get-server-details", id),
  getBackupRoutesByIP: (ip) => ipcRenderer.invoke("getBackupRoutesByIP", ip),
  processAllServers: () => ipcRenderer.invoke("process-all-servers"),
});

================
File: pruebas/cli.js
================
const oracledb = require('oracledb');
const yargs = require('yargs');
const fs = require('fs');
const path = require('path');

// Configuración de la conexión a la base de datos
const dbConfig = {
  user: 'USRMONBK', // Reemplaza con tu usuario de Oracle
  password: 'USRMONBK_2024', // Reemplaza con tu contraseña de Oracle
  connectString: '10.0.211.58:1521/MONBKPDB.cmac-arequipa.com.pe' // Reemplaza con tu cadena de conexión a Oracle
};

// Función para leer el archivo de log y procesar la última línea
async function readLogFile() {
  const logDir = path.join('C:\\Users\\igs_llupacca\\Documents\\backup_1'); // Ruta del directorio de logs
  const files = fs.readdirSync(logDir);
  const logFile = files.find(file => file.endsWith('.log'));

  if (!logFile) {
    console.error('No se encontró un archivo de log');
    return;
  }

  const fullPath = path.join(logDir, logFile);
  const data = fs.readFileSync(fullPath, 'utf8');
  const logLines = data.trim().split('\n');
  const lastLine = logLines[logLines.length - 1];
  const logDetails = parseLogLine(lastLine);

  console.log('Log output:', lastLine);
  console.log('Parsed Log Details:', logDetails);

  await storeLogDetails(logDetails);
}

// Función para analizar la última línea del archivo de log
function parseLogLine(logLine) {
  const datePattern = /\w{3} \w{3} \d{1,2} \d{2}:\d{2}:\d{2} \d{4}/;
  const match = logLine.match(datePattern);
  const dateTime = match ? match[0] : 'N/A';

  const durationPattern = /elapsed (.+)/;
  const durationMatch = logLine.match(durationPattern);
  const duration = durationMatch ? durationMatch[1] : 'N/A';

  const success = logLine.includes('successfully completed');

  return {
    dateTime,
    duration,
    success,
  };
}

// Función para almacenar los detalles del log en la base de datos
async function storeLogDetails(logDetails) {
  let connection;

  try {
    connection = await oracledb.getConnection(dbConfig);

    const result = await connection.execute(
      `INSERT INTO LogBackup (dateTime, duration, success) VALUES (:dateTime, :duration, :success)`,
      {
        dateTime: logDetails.dateTime,
        duration: logDetails.duration,
        success: logDetails.success ? 1 : 0
      },
      { autoCommit: true }
    );

    console.log('Log details stored successfully:', result);
  } catch (err) {
    console.error('Error storing log details:', err);
  } finally {
    if (connection) {
      try {
        await connection.close();
      } catch (err) {
        console.error('Error closing connection:', err);
      }
    }
  }
}

// Configurar los comandos de yargs
yargs.command({
  command: 'check-backups',
  describe: 'Check the status of backups',
  handler: async () => {
    let connection;

    try {
      connection = await oracledb.getConnection(dbConfig);
      const result = await connection.execute('SELECT * FROM LogBackup');
      console.log('Backup Logs:', result.rows);
    } catch (err) {
      console.error('Error fetching logs:', err);
    } finally {
      if (connection) {
        try {
          await connection.close();
        } catch (err) {
          console.error('Error closing connection:', err);
        }
      }
    }
  }
});

yargs.command({
  command: 'store-log',
  describe: 'Read the log file and store the last entry in the database',
  handler: async () => {
    await readLogFile();
  }
});

yargs.parse();

================
File: pruebas/connection.rdp
================
full address:s:10.0.212.172
username:s:10.0.212.172\\bknetworker

================
File: pruebas/index.js
================
const { Client } = require('ssh2');

const sshConfig = {
  host: 'servidor', // Reemplaza con la IP o el nombre de tu servidor
  port: 22,
  username: 'usuario', // Reemplaza con tu usuario SSH
  password: 'clave',   // Reemplaza con tu contraseña SSH
};

const logFilePath = '/ruta/a/logs/output_exp_controln_01-08-2024_21-30-02.log'; // Reemplaza con la ruta de tu archivo de log

const sshClient = new Client();

sshClient.on('ready', () => {
  console.log('SSH Connection ready');

  // Comando para leer la última línea del archivo de log
  const tailCommand = `tail -n 1 ${logFilePath}`;

  sshClient.exec(tailCommand, (err, stream) => {
    if (err) throw err;

    let logOutput = '';

    stream.on('close', (code, signal) => {
      console.log(`Stream closed with code: ${code}, signal: ${signal}`);
      console.log('Log output:', logOutput);
      
      // Aquí puedes procesar el `logOutput` para extraer la información necesaria
      const logLines = logOutput.trim().split('\n');
      const lastLine = logLines[logLines.length - 1];
      const logDetails = parseLogLine(lastLine);
      console.log('Parsed Log Details:', logDetails);

      sshClient.end();
    }).on('data', (data) => {
      logOutput += data.toString();
    }).stderr.on('data', (data) => {
      console.error(`STDERR: ${data}`);
    });
  });
}).connect(sshConfig);

// Función para analizar la última línea del archivo de log
function parseLogLine(logLine) {
  const datePattern = /\w{3} \w{3} \d{1,2} \d{2}:\d{2}:\d{2} \d{4}/;
  const match = logLine.match(datePattern);
  const dateTime = match ? match[0] : 'N/A';

  const durationPattern = /elapsed (.+)/;
  const durationMatch = logLine.match(durationPattern);
  const duration = durationMatch ? durationMatch[1] : 'N/A';

  const success = logLine.includes('successfully completed');

  return {
    dateTime,
    duration,
    success,
  };
}

================
File: pruebas/linux.js
================
const { Client } = require('ssh2');
const fs = require('fs');
const path = require('path');

// Configuración de conexión SSH
const sshConfig = {
  host: '10.0.212.4', // Reemplaza con la IP del servidor Linux
  port: 22,
  username: 'test', // Reemplaza con el nombre de usuario del servidor Linux
  password: 'password', // Reemplaza con la contraseña del servidor Linux
};

// Ruta del directorio donde están los archivos de log en el servidor Linux
const remoteLogDirectory = '/ruta/al/directorio/logs/';

// Función para buscar el archivo .log más reciente
function findLatestLogFile(client, directoryPath) {
  return new Promise((resolve, reject) => {
    const command = `ls -t ${directoryPath}*.log | head -n 1`;
    client.exec(command, (err, stream) => {
      if (err) return reject(`Error executing command: ${err}`);
      
      let latestFile = '';
      stream.on('data', (data) => {
        latestFile += data;
      }).on('close', () => {
        if (latestFile) {
          resolve(latestFile.trim());
        } else {
          reject('No log files found');
        }
      });
    });
  });
}

// Función para leer la última línea relevante del archivo de log
function readLastLogLine(client, logFilePath) {
  return new Promise((resolve, reject) => {
    const command = `tail -n 1 ${logFilePath}`;
    client.exec(command, (err, stream) => {
      if (err) return reject(`Error executing command: ${err}`);
      
      let lastLine = '';
      stream.on('data', (data) => {
        lastLine += data;
      }).on('close', () => {
        resolve(lastLine.trim());
      });
    });
  });
}

// Conexión SSH y ejecución
const conn = new Client();
conn.on('ready', async () => {
  console.log('SSH Connection established');
  
  try {
    const latestLogFile = await findLatestLogFile(conn, remoteLogDirectory);
    console.log(`Latest log file: ${latestLogFile}`);

    const lastLogLine = await readLastLogLine(conn, latestLogFile);
    console.log('Log output:', lastLogLine);

    // Aquí puedes agregar la lógica para procesar y almacenar la línea del log si es necesario
  } catch (err) {
    console.error(err);
  } finally {
    conn.end();
  }
}).connect(sshConfig);

================
File: pruebas/prueba.js
================
const fs = require('fs');
const path = require('path');
const oracledb = require('oracledb');
const { Document, Packer, Paragraph, TextRun } = require('docx');

const logDirectoryPath = 'C:\\Users\\igs_llupacca\\Documents\\backup_1';
let logOutput = '';

// Función para obtener el archivo .log más reciente
function getLatestLogFile(directoryPath) {
  return new Promise((resolve, reject) => {
    fs.readdir(directoryPath, (err, files) => {
      if (err) {
        logOutput += `Error reading directory: ${err}\n`;
        return reject(`Error reading directory: ${err}`);
      }

      const logFiles = files.filter(file => path.extname(file) === '.log');

      if (logFiles.length === 0) {
        logOutput += 'No log files found in the directory\n';
        return reject('No log files found in the directory');
      }

      let latestFile = logFiles[0];
      let latestFileTime = fs.statSync(path.join(directoryPath, latestFile)).mtimeMs;

      for (const file of logFiles) {
        const filePath = path.join(directoryPath, file);
        const fileTime = fs.statSync(filePath).mtimeMs;

        if (fileTime > latestFileTime) {
          latestFile = file;
          latestFileTime = fileTime;
        }
      }

      resolve(path.join(directoryPath, latestFile));
    });
  });
}

// Función para obtener el tamaño del archivo .DMP en MB
function getDumpFileSize(directoryPath) {
  return new Promise((resolve, reject) => {
    fs.readdir(directoryPath, (err, files) => {
      if (err) {
        logOutput += `Error reading directory: ${err}\n`;
        return reject(`Error reading directory: ${err}`);
      }

      const dumpFiles = files.filter(file => path.extname(file).toUpperCase() === '.DMP');

      if (dumpFiles.length === 0) {
        logOutput += 'No .DMP files found in the directory\n';
        return reject('No .DMP files found in the directory');
      }

      let latestDumpFile = dumpFiles[0];
      let latestDumpFileTime = fs.statSync(path.join(directoryPath, latestDumpFile)).mtimeMs;

      for (const file of dumpFiles) {
        const filePath = path.join(directoryPath, file);
        const fileTime = fs.statSync(filePath).mtimeMs;

        if (fileTime > latestDumpFileTime) {
          latestDumpFile = file;
          latestDumpFileTime = fileTime;
        }
      }

      const dumpFilePath = path.join(directoryPath, latestDumpFile);
      const dumpFileSizeInBytes = fs.statSync(dumpFilePath).size;
      const dumpFileSizeInMB = (dumpFileSizeInBytes / (1024 * 1024)).toFixed(2);

      resolve({
        filePath: dumpFilePath,
        fileSize: parseFloat(dumpFileSizeInMB) // Convertir a número
      });
    });
  });
}

// Función para leer el archivo de log y procesar la última línea
async function readLogFile() {
  try {
    const logFilePath = await getLatestLogFile(logDirectoryPath);
    const dumpFileInfo = await getDumpFileSize(logDirectoryPath);

    fs.readFile(logFilePath, 'utf8', async (err, data) => {
      if (err) {
        logOutput += `Error reading log file: ${err}\n`;
        console.error(`Error reading log file: ${err}`);
        saveLogOutputToWord(logOutput);
        return;
      }

      const logLines = data.trim().split('\n');
      const lastLine = logLines[logLines.length - 1];
      const logDetails = parseLogLine(lastLine);

      logOutput += `Log output: ${lastLine}\n`;
      logOutput += `Parsed Log Details:\n  dateTime: ${logDetails.dateTime}\n  duration: ${logDetails.duration}\n  success: ${logDetails.success}\n`;
      logOutput += `Dump file path: ${dumpFileInfo.filePath}\n`;
      logOutput += `Dump file size: ${dumpFileInfo.fileSize} MB\n`;

      console.log('Log output:', lastLine);
      console.log('Parsed Log Details:', logDetails);
      console.log('Dump file path:', dumpFileInfo.filePath);
      console.log('Dump file size:', dumpFileInfo.fileSize, 'MB');

      await storeLogDetails(logDetails, dumpFileInfo.fileSize);
      saveLogOutputToWord(logOutput);
    });
  } catch (error) {
    logOutput += `${error}\n`;
    console.error(error);
    saveLogOutputToWord(logOutput);
  }
}

// Función para analizar la última línea del archivo de log
function parseLogLine(logLine) {
  const datePattern = /\w{3} \w{3} \d{1,2} \d{2}:\d{2}:\d{2} \d{4}/;
  const match = logLine.match(datePattern);
  const dateTime = match ? match[0] : 'N/A';

  const durationPattern = /elapsed (.+)/;
  const durationMatch = logLine.match(durationPattern);
  const duration = durationMatch ? durationMatch[1] : 'N/A';

  const success = logLine.includes('successfully completed');

  return {
    dateTime,
    duration,
    success,
  };
}

// Función para almacenar los detalles del log en la base de datos
async function storeLogDetails(logDetails, dumpFileSize) {
  let connection;

  try {
    connection = await oracledb.getConnection({
      user: 'USRMONBK',
      password: 'USRMONBK_2024',
      connectString: '10.0.211.58:1521/MONBKPDB.cmac-arequipa.com.pe'
    });

    const checkExistQuery = `SELECT COUNT(*) as count FROM LogBackup WHERE dateTime = :dateTime`;
    const checkExistResult = await connection.execute(checkExistQuery, { dateTime: logDetails.dateTime });

    if (checkExistResult.rows[0].COUNT > 0) {
      logOutput += `Log entry with dateTime ${logDetails.dateTime} already exists.\n`;
      console.log(`Log entry with dateTime ${logDetails.dateTime} already exists.`);
    } else {
      const result = await connection.execute(
        `INSERT INTO LogBackup (dateTime, duration, success, dumpFileSize_MB) VALUES (:dateTime, :duration, :success, :dumpFileSize)`,
        {
          dateTime: logDetails.dateTime,
          duration: logDetails.duration,
          success: logDetails.success ? 1 : 0,
          dumpFileSize: dumpFileSize // Asegúrate de que sea un número
        },
        { autoCommit: true }
      );

      logOutput += `Log details stored successfully.\n`;
      console.log('Log details stored successfully:', result);
    }
  } catch (err) {
    logOutput += `Error storing log details: ${err}\n`;
    console.error('Error storing log details:', err);
  } finally {
    if (connection) {
      try {
        await connection.close();
      } catch (err) {
        logOutput += `Error closing connection: ${err}\n`;
        console.error('Error closing connection:', err);
      }
    }
  }
}

// Función para guardar el contenido de la consola en un archivo de Word
function saveLogOutputToWord(logOutput) {
  const doc = new Document({
    sections: [
      {
        properties: {},
        children: logOutput.split('\n').map(line => new Paragraph(line)),
      },
    ],
  });

  const now = new Date();
  const formattedDate = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`;
  const formattedTime = `${now.getHours().toString().padStart(2, '0')}-${now.getMinutes().toString().padStart(2, '0')}-${now.getSeconds().toString().padStart(2, '0')}`;
  const fileName = `logOutput_${formattedDate}_${formattedTime}.docx`;

  Packer.toBuffer(doc).then((buffer) => {
    fs.writeFileSync(fileName, buffer);
    console.log(`Log output saved to ${fileName}`);
  });
}
module.exports = {
  readLogFile
};


// Leer el archivo de log y procesar la última línea
readLogFile();

================
File: pruebas/readme.md
================
# Heading

Pasos para Ejecutar el Script CLI:
Ejecutar el Comando para Almacenar el Log:
--node cli.js store-log
Ejecutar el Comando para Verificar los Backups:
--node cli.js check-backups
para preueba.js = node prueba.js

================
File: pruebas/rendererLinux.js
================
document.addEventListener('DOMContentLoaded', () => {
    const urlParams = new URLSearchParams(window.location.search);
    const ip = urlParams.get('ip');
    const port = urlParams.get('port');
    const username = urlParams.get('username');
    const password = urlParams.get('password');
    
    const resultDiv = document.getElementById('result');
    const directoryPath = '/temporal1T/BK_SWITCH/BK_CAJERO_2024_08_16_0425'; // Ruta específica para Linux
  
    async function handleConnection() {
      try {
        const isConnected = await window.electron.connectToServer(ip, port, username, password);
        if (isConnected) {
          resultDiv.style.display = 'block'; // Mostrar resultados
          document.getElementById('server-ip').textContent = ip;
  
          try {
            const { logDetails, dumpFileInfo } = await window.electron.getLogDetails(directoryPath, ip, port, username, password);
  
            // Mostrar los detalles del log y archivo DMP
            document.getElementById('log-date').textContent = logDetails.dateTime;
            document.getElementById('duration').textContent = logDetails.duration;
            document.getElementById('success').textContent = logDetails.success ? 'Sí' : 'No';
            document.getElementById('dump-path').textContent = dumpFileInfo.filePath;
            document.getElementById('dump-size').textContent = `${dumpFileInfo.fileSize} MB`;
  
            // Guardar los detalles en la base de datos
            await window.electron.saveLogToDatabase(logDetails, dumpFileInfo);
          } catch (error) {
            resultDiv.innerHTML += `<br>Error al obtener los detalles del log: ${error.message}`;
          }
        } else {
          resultDiv.style.display = 'block';
          resultDiv.textContent = `No se pudo conectar a ${ip}:${port}`;
        }
      } catch (error) {
        resultDiv.style.display = 'block';
        resultDiv.innerHTML = `Error de conexión: ${error.message}`;
      }
    }
  
    handleConnection();
  });

================
File: pruebas/rendererSolaris.js
================
document.addEventListener('DOMContentLoaded', () => {
    const urlParams = new URLSearchParams(window.location.search);
    const ip = urlParams.get('ip');
    const port = urlParams.get('port');
    const username = urlParams.get('username');
    const password = urlParams.get('password');
    
    const resultDiv = document.getElementById('result');
    const directoryPath = '/temporal2T/BK_BANTPROD_DIARIO/DTPUMP'; // Ruta específica para Solaris
  
    async function handleConnection() {
      try {
        const isConnected = await window.electron.connectToServer(ip, port, username, password);
        if (isConnected) {
          resultDiv.style.display = 'block'; // Mostrar resultados
          document.getElementById('server-ip').textContent = ip;
  
          try {
            const { logDetails, dumpFileInfo } = await window.electron.getLogDetails(directoryPath, ip, port, username, password);
  
            // Mostrar los detalles del log y archivo DMP
            document.getElementById('log-date').textContent = logDetails.dateTime;
            document.getElementById('duration').textContent = logDetails.duration;
            document.getElementById('success').textContent = logDetails.success ? 'Sí' : 'No';
            document.getElementById('dump-path').textContent = dumpFileInfo.filePath;
            document.getElementById('dump-size').textContent = `${dumpFileInfo.fileSize} MB`;
  
            // Guardar los detalles en la base de datos
            await window.electron.saveLogToDatabase(logDetails, dumpFileInfo);
          } catch (error) {
            resultDiv.innerHTML += `<br>Error al obtener los detalles del log: ${error.message}`;
          }
        } else {
          resultDiv.style.display = 'block';
          resultDiv.textContent = `No se pudo conectar a ${ip}:${port}`;
        }
      } catch (error) {
        resultDiv.style.display = 'block';
        resultDiv.innerHTML = `Error de conexión: ${error.message}`;
      }
    }
  
    handleConnection();
  });

================
File: pruebas/solaris.js
================
const { Client } = require('ssh2');

// Configuración de conexión SSH para Solaris
const connectionConfig = {
  host: '10.0.212.211', // Reemplaza con la IP o hostname del servidor Solaris
  port: 22, 
  username: 'solaris_user', // Reemplaza con tu usuario
  password: 'solaris_password' // Reemplaza con tu contraseña
};

// Comando para encontrar el archivo .log más reciente y leer su última línea
const findLogCommand = `
cd /ruta/a/logs && 
latestLog=$(ls -t *.log | head -n 1) && 
tail -n 1 "$latestLog"
`;

const conn = new Client();
conn.on('ready', () => {
  console.log('Conectado a Solaris');
  
  conn.exec(findLogCommand, (err, stream) => {
    if (err) throw err;
    
    stream.on('close', (code, signal) => {
      console.log('Comando ejecutado, cerrando conexión.');
      conn.end();
    }).on('data', (data) => {
      console.log('Última línea del log:', data.toString());
    }).stderr.on('data', (data) => {
      console.error('Error:', data.toString());
    });
  });
}).connect(connectionConfig);

================
File: pruebas/ssh.js
================
const net = require('net');

const server = '10.0.212.44';
const port = 22;

const socket = new net.Socket();

socket.setTimeout(3000); // Timeout de 3 segundos

socket.on('connect', function() {
    console.log('Conexión exitosa al puerto 22 en el servidor');
    socket.destroy();
});

socket.on('timeout', function() {
    console.error('Conexión a tiempo');
    socket.destroy();
});

socket.on('error', function(err) {
    console.error('Error en la conexión:', err.message);
});

socket.connect(port, server);

================
File: pruebas/windows.js
================
const { exec } = require('child_process');

// Configurar credenciales usando cmdkey
const configureCredentials = (host, userName, password) => {
  return new Promise((resolve, reject) => {
    const command = `cmdkey /add:${host} /user:${userName} /pass:${password}`;
    exec(command, (error, stdout, stderr) => {
      if (error) {
        return reject(`Error configuring credentials: ${error.message}`);
      }
      if (stderr) {
        return reject(`cmdkey stderr: ${stderr}`);
      }
      resolve(stdout);
    });
  });
};

// Iniciar conexión RDP
const startRDPConnection = (host) => {
  return new Promise((resolve, reject) => {
    const command = `start mstsc /v:${host}`;
    exec(command, (error, stdout, stderr) => {
      if (error) {
        return reject(`Error starting RDP connection: ${error.message}`);
      }
      if (stderr) {
        return reject(`mstsc stderr: ${stderr}`);
      }
      resolve(stdout);
    });
  });
};

// Ejemplo de uso
(async () => {
  try {
    await configureCredentials('10.0.212.172', 'bknetworker', 'BKn3t$$2017');
    console.log('Credenciales configuradas correctamente.');
    
    await startRDPConnection('10.0.212.172');
    console.log('Intentando conectar al servidor RDP...');
  } catch (error) {
    console.error(error);
  }
})();

================
File: pruebas/windows2.js
================
const Client = require('ssh2-sftp-client');
const sftp = new Client();

async function connectSFTP() {
    try {
        await sftp.connect({
            host: '10.0.212.172',     // Reemplaza con la IP del servidor SFTP
            port: '22',               // Puerto para SFTP (22 es el puerto predeterminado)
            username: 'bknetworker',  // Reemplaza con tu nombre de usuario SFTP
            password: 'BKn3t$$2017'   // Reemplaza con tu contraseña SFTP
        });
        console.log('Conectado al servidor SFTP');
    } catch (err) {
        console.error('Error en la conexión SFTP:', err);
    } finally {
        sftp.end();
    }
}

connectSFTP();

================
File: renderer.js
================
let gridApi = null;
document.addEventListener("DOMContentLoaded", async () => {
  const currentPage = window.location.pathname;
  const backButton = document.getElementById("back-button");
  console.log("Current Page Path:", currentPage);

  // Obtener los elementos del DOM
  const osSelect = document.getElementById("os");
  const ipSelect = document.getElementById("ip");
  const editServerBtn = document.getElementById("edit-server-btn");
  const addServerBtn = document.getElementById("add-server-btn");
  const logEntriesContainer = document.getElementById("log-entries");
  const resultDiv = document.getElementById("result");
  const selectServerBtn = document.getElementById("select-server-btn");
  const deleteServerBtn = document.getElementById("delete-server-btn");
  const backupRouteSelect = document.getElementById("backup-routes");
  //const tooltipError = document.createElement("div");
  const processAllServersBtn = document.getElementById(
    "process-all-servers-btn"
  );
  const gridContainer = document.getElementById("gridContainer");
  const gridDiv = document.querySelector("#myGrid");

  let currentOS = ""; // Variable para el sistema operativo actual
  let selectedServer = null;
  // *** Función para actualizar las rutas de backup ***
  async function updateBackupRoutes() {
    const selectedIP = ipSelect.value; // IP seleccionada
    console.log("IP seleccionada:", selectedIP); // Asegúrate de que esto se ejecute

    if (!selectedIP) {
      console.log("No hay IP seleccionada.");
      return;
    }

    try {
      console.log(`Obteniendo rutas de backup para la IP: ${selectedIP}`);

      // Llamar a la función del main process para obtener las rutas de backup
      const backupRoutes = await window.electron.getBackupRoutesByIP(
        selectedIP
      );

      console.log("Rutas de backup obtenidas:", backupRoutes); // Verifica que recibes datos

      // Limpiar las rutas previas
      backupRouteSelect.innerHTML = "";

      if (backupRoutes.length > 0) {
        backupRoutes.forEach((route) => {
          const option = document.createElement("option");
          option.value = route.backupPath;
          option.textContent = route.backupPath;
          backupRouteSelect.appendChild(option);
        });
      } else {
        backupRouteSelect.innerHTML =
          "<option>No se encontraron rutas</option>";
      }
    } catch (error) {
      console.error("Error al obtener las rutas de backup:", error);
      backupRouteSelect.innerHTML = "<option>Error al cargar rutas</option>";
    }
  }
  // *** Función para cargar servidores ***
  async function loadServers() {
    try {
      const servers = await window.electron.getServers();
      console.log("Servidores recuperados:", servers);
      return servers;
    } catch (error) {
      console.error("Error al recuperar los servidores:", error);
      return [];
    }
  }

  let servers = await loadServers(); // Cargamos los servidores al inicio

  // *** Página de selección de servidores ***
  if (currentPage.includes("select-server.html")) {
    const serverListDiv = document.getElementById("server-list");

    // Si hay servidores, los mostramos
    if (servers.length > 0) {
      servers.forEach((server) => {
        const serverItem = document.createElement("div");
        serverItem.className = "server-item";
        serverItem.textContent = `Nombre: ${server.name} - IP: ${server.ip}`;

        serverItem.addEventListener("click", () => {
          document
            .querySelectorAll(".server-item")
            .forEach((item) => item.classList.remove("selected"));
          serverItem.classList.add("selected");
          selectedServer = server;
          selectServerBtn.disabled = false; // Habilitar el botón cuando se seleccione un servidor
          deleteServerBtn.disabled = false;
        });

        serverListDiv.appendChild(serverItem); // Añadir los servidores a la lista
      });
    } else {
      serverListDiv.textContent = "No se encontraron servidores.";
    }

    // Manejar la selección de servidor para editar
    if (selectServerBtn) {
      selectServerBtn.addEventListener("click", () => {
        if (selectedServer) {
          window.localStorage.setItem(
            "selectedServer",
            JSON.stringify(selectedServer)
          );
          window.location.href = "edit-server.html"; // Redirigir a la página de edición
        }
      });
      // *** Botón para eliminar servidor ***
      if (deleteServerBtn) {
        deleteServerBtn.addEventListener("click", async () => {
          if (selectedServer) {
            const confirmDelete = confirm(
              `¿Estás seguro de que deseas eliminar el servidor ${selectedServer.name}?`
            );
            if (confirmDelete) {
              const result = await window.electron.deleteServer(
                selectedServer.id
              );
              if (result.success) {
                alert("Servidor eliminado correctamente.");
                window.location.reload(); // Recargar la página para reflejar los cambios
              } else {
                alert("Error al eliminar el servidor: " + result.error);
              }
            }
          }
        });
      }
    }
  }
  // *** Botón para agregar servidor ***
  if (addServerBtn) {
    addServerBtn.addEventListener("click", () => {
      window.localStorage.removeItem("selectedServer"); // Elimina cualquier selección previa de servidor
      window.location.href = "add-server.html"; // Redirigir a la página de agregar servidor
    });
  }
  // *** Verifica si estamos en la página de agregar o editar servidor ***
  if (
    currentPage.includes("add-server.html") ||
    currentPage.includes("edit-server.html")
  ) {
    const serverData = JSON.parse(
      window.localStorage.getItem("selectedServer")
    );

    // Verifica si estamos en la página de agregar o editar servidor
    if (currentPage.includes("edit-server.html")) {
      const selectedServer = JSON.parse(
        window.localStorage.getItem("selectedServer")
      );

      // Verificamos si existe un servidor seleccionado
      if (selectedServer && selectedServer.id) {
        const serverId = selectedServer.id;

        console.log("Llamando a getServerDetails con el ID:", serverId); // LOG AQUÍ

        try {
          console.log("Cargando detalles del servidor con ID:", serverId);

          // Llamamos a la función de electron para obtener los detalles del servidor
          const serverData = await window.electron.getServerDetails(serverId);

          if (serverData && !serverData.error) {
            // Llenamos el formulario con los datos recibidos del servidor
            document.getElementById("server-id").value = serverData.id || "";
            document.getElementById("server-name").value =
              serverData.serverName || "";
            document.getElementById("ip").value = serverData.ip || "";
            document.getElementById("os").value = serverData.os || "";
            document.getElementById("port").value = serverData.port || "";
            document.getElementById("username").value = (
              serverData.username || ""
            ).replace(/^"|"$/g, "");
            document.getElementById("password").value = (
              serverData.password || ""
            ).replace(/^"|"$/g, "");

            console.log("Formulario actualizado con los datos del servidor.");
          } else {
            console.error("No se pudieron cargar los detalles del servidor.");
          }
        } catch (error) {
          console.error("Error al obtener los detalles del servidor:", error);
        }
      } else {
        console.error("No se ha seleccionado ningún servidor.");
        window.location.href = "select-server.html"; // Redirigir si no hay servidor seleccionado
      }
    }
    // Enviar cambios al editar
    const editServerForm = document.getElementById("edit-server-form");

    if (editServerForm) {
      editServerForm.addEventListener("submit", async (event) => {
        event.preventDefault();

        const serverData = {
          id: document.getElementById("server-id").value,
          serverName: document.getElementById("server-name").value,
          ip: document.getElementById("ip").value,
          os: document.getElementById("os").value,
          port: document.getElementById("port").value,
          username: document.getElementById("username").value,
          password: document.getElementById("password").value,
        };

        console.log("Editando servidor:", serverData);

        try {
          const result = await window.electron.updateServer(serverData);

          if (result.success) {
            alert("Servidor actualizado correctamente.");
            window.localStorage.removeItem("selectedServer");
            window.location.href = "select-server.html";
          } else {
            alert("Error al actualizar el servidor.");
          }
        } catch (error) {
          console.error("Error al actualizar el servidor:", error);
          alert("Hubo un error al actualizar el servidor.");
        }
      });
    }

    // *** Agregar o editar el servidor al enviar el formulario ***
    const addServerForm = document.getElementById("add-server-form");

    if (addServerForm) {
      addServerForm.addEventListener("submit", async (event) => {
        event.preventDefault();

        const serverData = {
          serverName: document.getElementById("server-name").value,
          ip: document.getElementById("ip").value,
          os: document.getElementById("os").value,
          port: document.getElementById("port").value,
          username: document.getElementById("username").value,
          password: document.getElementById("password").value,
        };

        try {
          let result;
          if (currentPage.includes("add-server.html")) {
            // Si estamos en la página de agregar
            result = await window.electron.addServer(serverData);
          } else {
            // Si estamos en la página de edición
            result = await window.electron.updateServer(serverData);
          }

          if (result.success) {
            alert("Servidor guardado correctamente.");
            window.localStorage.removeItem("selectedServer"); // Eliminar el servidor seleccionado del localStorage
            window.location.href = "index.html"; // Redirigir a la página principal
          } else {
            alert("Error al guardar el servidor.");
          }
        } catch (error) {
          console.error("Error al guardar el servidor:", error);
          alert("Hubo un error al guardar el servidor.");
        }
      });
    }
  }

  // *** Redirigir al selector de servidores cuando se hace clic en Editar ***
  if (editServerBtn) {
    editServerBtn.addEventListener("click", () => {
      window.location.href = "select-server.html"; // Redirigir a la nueva página de selección de servidores
    });
  }

  // *** Función para actualizar las opciones de IP en base al sistema operativo ***
  async function updateIPOptions() {
    if (currentPage.includes("index.html")) {
      try {
        const servers = (await window.electron.getServers()) || [];
        const selectedOS = osSelect.value;

        ipSelect.innerHTML = ""; // Limpia las opciones previas
        const filteredServers = servers.filter(
          (server) => server.os === selectedOS
        );

        if (filteredServers.length > 0) {
          filteredServers.forEach((server) => {
            const option = document.createElement("option");
            option.value = server.ip;
            option.textContent = server.ip;
            ipSelect.appendChild(option);
          });
          // Si hay opciones de IP disponibles, selecciona la primera por defecto
          if (ipSelect.options.length > 0) {
            ipSelect.value = ipSelect.options[0].value;
            updateBackupRoutes(); // Forzar la actualización de las rutas de backup
          }
        } else {
          ipSelect.disabled = true;
          console.log(
            "No hay servidores disponibles para este sistema operativo."
          );
        }
      } catch (error) {
        console.error("Error al actualizar las opciones de IP:", error);
      }
    }
  }

  if (osSelect) {
    osSelect.addEventListener("change", updateIPOptions); // Cuando cambie el OS, actualiza las IPs
    updateIPOptions(); // Llama a la función al cargar para llenar las IPs del OS seleccionado por defecto
  }

  function showLoading() {
    document.getElementById("loading-overlay").style.display = "flex";
  }

  function hideLoading() {
    document.getElementById("loading-overlay").style.display = "none";
  }

  function showAuthErrorModal(errorMessage) {
    requestAnimationFrame(() => {
      const modalAuthError = document.getElementById("authErrorModal");
      const message = document.getElementById("errorMessage");
      if (modalAuthError && message) {
        message.textContent =
          errorMessage ||
          "Error de autenticación. Por favor, inténtelo de nuevo.";
        modalAuthError.style.display = "block";

        const retryButton = document.getElementById("retryButton");
        const closeAuthModal = document.getElementById("closeModal");

        if (retryButton) {
          retryButton.onclick = function () {
            modalAuthError.style.display = "none";
          };
        }

        if (closeAuthModal) {
          closeAuthModal.onclick = function () {
            modalAuthError.style.display = "none";
          };
        }

        window.onclick = function (event) {
          if (event.target == modalAuthError) {
            modalAuthError.style.display = "none";
          }
        };
      }
    });
  }

  function clearLogEntries() {
    if (logEntriesContainer) {
      logEntriesContainer.innerHTML = ""; // Limpiar los logs anteriores
    }
  }

  function formatFileSize(sizeInMB) {
    if (sizeInMB >= 1000) {
      let sizeInGB = (sizeInMB / 1000).toFixed(2);
      return `${sizeInGB} GB`;
    } else {
      return `${sizeInMB.toFixed(2)} MB`;
    }
  }
  if (
    typeof agGrid === "undefined" ||
    typeof agGrid.createGrid === "undefined"
  ) {
    console.error(
      "AG-Grid o createGrid no está definido. Verifica que el script se ha cargado correctamente y es la versión 31+."
    );
    return;
  }
  if (gridDiv) {
    console.log("Elemento del grid encontrado, inicializando...");
    initGrid(gridDiv);
  } else {
    console.error("Elemento #myGrid no encontrado");
  }

  if (processAllServersBtn) {
    processAllServersBtn.addEventListener("click", startProcessAllServers);
  } else {
    console.error("Botón process-all-servers-btn no encontrado");
  }

  function initGrid(gridDiv) {
    const gridOptions = {
      columnDefs: [
        {
          headerName: "Servidor",
          field: "serverName",
          sortable: true,
          filter: true,
          minWidth: 120,
        },
        {
          headerName: "IP",
          field: "ip",
          sortable: true,
          filter: true,
          minWidth: 100,
        },
        {
          headerName: "Estado",
          field: "status",
          sortable: true,
          filter: true,
          minWidth: 80,
        },
        {
          headerName: "Archivo de Log",
          field: "logFileName",
          sortable: true,
          filter: true,
          minWidth: 150,
        },
        {
          headerName: "Hora de Inicio",
          field: "startTime",
          sortable: true,
          filter: true,
          minWidth: 150,
        },
        {
          headerName: "Hora de Fin",
          field: "endTime",
          sortable: true,
          filter: true,
          minWidth: 150,
        },
        {
          headerName: "Duración",
          field: "duration",
          sortable: true,
          filter: true,
          minWidth: 100,
        },
        {
          headerName: "Tamaño Total DMP",
          field: "totalDmpSize",
          sortable: true,
          filter: true,
          minWidth: 100,
        },
        {
          headerName: "Tamaño Total Carpeta",
          field: "totalFolderSize",
          sortable: true,
          filter: true,
          minWidth: 100,
        },
        {
          headerName: "Estado de Backup",
          field: "backupStatus",
          sortable: true,
          filter: true,
          minWidth: 80,
        },
        {
          headerName: "Ruta de Backup",
          field: "backupPath",
          sortable: true,
          filter: true,
          minWidth: 150,
        },
      ],
      pagination: true, // Habilita la paginación
      paginationPageSize: 10, // Número de filas por página
      defaultColDef: {
        resizable: true,
        sortable: true,
        filter: true, // Asegúrate de que los filtros estén habilitados aquí
      },
      rowData: [],
      onGridReady: (params) => {
        params.api.sizeColumnsToFit();
      },
      domLayout: "autoHeight",
      onFirstDataRendered: (params) => {
        params.api.autoSizeAllColumns();
      },
      //domLayout: 'autoWidht'
    };

    try {
      gridApi = agGrid.createGrid(gridDiv, gridOptions);
      console.log("Grid inicializado correctamente");
      window.addEventListener("resize", () => gridApi.sizeColumnsToFit());
    } catch (error) {
      console.error("Error al inicializar AG-Grid:", error);
    }
  }

  async function startProcessAllServers() {
    console.log("Iniciando proceso de todos los servidores");
    try {
      showLoading();
      const result = await window.electron.processAllServers();
      hideLoading();

      if (result.success) {
        // Mostrar el contenedor del grid
        gridContainer.style.display = "block";

        // Inicializar el grid si aún no se ha hecho
        if (!gridApi) {
          initGrid(gridDiv);
        }

        displayAllServersResults(result.results);
      } else {
        console.error("Error al procesar los servidores:", result.error);
        showErrorMessage("Error al procesar los servidores: " + result.error);
      }
    } catch (error) {
      hideLoading();
      console.error("Error:", error);
      showErrorMessage("Error: " + error.message);
    }
  }

  function displayAllServersResults(results) {
    console.log("Mostrando resultados de servidores:", results);

    if (gridApi && typeof gridApi.setRowData === "function") {
      const rowData = results.flatMap((serverResult) => {
        const processLogDetail = (logDetail) => {
          const status = serverResult.error
            ? "Error"
            : logDetail.logDetails?.success
            ? "Éxito"
            : "Fallo";
          const successClass = logDetail.logDetails?.success ? "" : "error-box";

          const totalDmpSize = logDetail.dumpFileInfo.reduce(
            (sum, file) => sum + file.fileSize,
            0
          );
          const formattedDmpSize = formatFileSize(totalDmpSize); // Aquí usamos la nueva función
          const formattedFolderSize = logDetail.totalFolderSize
            ? formatFileSize(parseFloat(logDetail.totalFolderSize)) // Si hay tamaño de carpeta, lo formateamos
            : "N/A"; // Si no hay tamaño de carpeta, mostramos "N/A"

          return {
            serverName: serverResult.serverName,
            ip: serverResult.ip,
            status: status,
            statusClass: successClass,
            logFileName: logDetail.logFileName || "N/A",
            startTime: logDetail.logDetails?.startTime || "N/A",
            endTime: logDetail.logDetails?.endTime || "N/A",
            duration: logDetail.logDetails?.duration || "N/A",
            totalDmpSize: formattedDmpSize, // Cambiado de formattedDmpSize
            totalFolderSize: formattedFolderSize, // Cambiado de formattedFolderSize
            backupStatus: logDetail.logDetails?.backupStatus || "N/A",
            backupPath: logDetail.backupPath || "N/A",
            oraError: logDetail.logDetails?.oraError
              ? JSON.stringify(logDetail.logDetails.oraError)
              : null,
          };
        };

        if (Array.isArray(serverResult.logDetails)) {
          return serverResult.logDetails.map((logDetail) =>
            processLogDetail(logDetail)
          );
        } else {
          return [processLogDetail(serverResult.logDetails || {})];
        }
      });

      try {
        gridApi.setRowData(rowData);
        console.log("Datos cargados en el grid");

        // Configurar las columnas del grid
        const columnDefs = [
          { field: "serverName", headerName: "Server Name" },
          { field: "ip", headerName: "IP" },
          {
            field: "status",
            headerName: "Status",
            cellRenderer: (params) => {
              return `<div class="${params.data.statusClass}">${params.value}</div>`;
            },
          },
          { field: "logFileName", headerName: "Log File Name" },
          { field: "startTime", headerName: "Start Time" },
          { field: "endTime", headerName: "End Time" },
          { field: "duration", headerName: "Duration" },
          { field: "totalDmpSize", headerName: "Total Dump Size" },
          { field: "totalFolderSize", headerName: "Total Folder Size" },
          { field: "backupStatus", headerName: "Backup Status" },
          { field: "backupPath", headerName: "Backup Path" },
        ];

        gridApi.setColumnDefs(columnDefs);

        let tooltipVisible = false;

        // Configurar el evento de clic en celda para mostrar el tooltip de error
        gridApi.addEventListener("cellClicked", (params) => {
          if (
            params.column.colId === "status" &&
            params.data.statusClass === "error-box"
          ) {
            const tooltipError =
              document.getElementById("tooltipError") ||
              (() => {
                const div = document.createElement("div");
                div.id = "tooltipError";
                div.classList.add("tooltip-error");
                document.body.appendChild(div);
                return div;
              })();

            if (tooltipVisible) {
              tooltipError.style.display = "none";
              tooltipVisible = false;
              return;
            }

            if (params.data.oraError) {
              const oraError = JSON.parse(params.data.oraError);
              tooltipError.innerHTML = `
                            <p><strong>Error ORA encontrado:</strong></p>
                            <p>${oraError.previousLine}</p>
                            <p><strong>${oraError.errorLine}</strong></p>
                            <p>${oraError.nextLine}</p>
                        `;
            } else {
              tooltipError.textContent =
                "No se encontraron detalles específicos del error.";
            }

            const rect = params.event.target.getBoundingClientRect();
            tooltipError.style.top = `${rect.top + window.scrollY}px`;
            tooltipError.style.left = `${rect.right + 10}px`;
            tooltipError.style.display = "block";
            tooltipVisible = true;
          }
        });

        // Agregar evento para ocultar el tooltip al hacer clic en cualquier lugar
        document.addEventListener("click", (event) => {
          const tooltipError = document.getElementById("tooltipError");
          if (
            tooltipError &&
            tooltipVisible &&
            !tooltipError.contains(event.target)
          ) {
            tooltipError.style.display = "none";
            tooltipVisible = false;
          }
        });
      } catch (error) {
        console.error("Error al cargar datos en el grid:", error);
      }
    } else {
      console.warn("Grid API no disponible o setRowData no es una función");
    }
  }
  function showErrorMessage(message) {
    console.error("Error:", message);
    alert(message);
  }
  function addLogEntry(logData) {
    if (logEntriesContainer) {
      const entryDiv = document.createElement("div");
      entryDiv.className = "log-entry";

      // Verifica que 'serverName' esté correctamente asignado
      const serverName = logData.serverName || "N/A";

      // Añade este log para verificar el valor en el lado del cliente
      console.log(
        "Tamaño de la carpeta recibido (logData.totalFolderSize):",
        logData.totalFolderSize
      );
      console.log("Datos del log:", logData); // Para depuración
      // Si el valor de success es No, aplicar la clase 'error' a todo el párrafo
      const successClass = logData.logDetails.success ? "" : "error-box";

      const totalDmpSize = logData.dumpFileInfo.reduce(
        (sum, file) => sum + file.fileSize,
        0
      );
      const formattedDmpSize = formatFileSize(totalDmpSize); // Aquí usamos la nueva función
      const formattedFolderSize = logData.totalFolderSize
        ? formatFileSize(parseFloat(logData.totalFolderSize)) // Si hay tamaño de carpeta, lo formateamos
        : "N/A"; // Si no hay tamaño de carpeta, mostramos "N/A"
      // Añadir el estado del backup
      const backupStatus = logData.logDetails.backupStatus || "N/A";

      entryDiv.innerHTML = `
            <p><strong>Server IP:</strong> ${
              logData.ip
            }<strong> Server Name:</strong> ${serverName}</p>
            <p><strong>Start Time:</strong> ${
              logData.logDetails.startTime || "N/A"
            }</p>
            <p><strong>End Time:</strong> ${
              logData.logDetails.endTime || "N/A"
            }</p>
            <p><strong>Backup Status:</strong> ${backupStatus}</p>
            <p><strong>Duration:</strong> ${
              logData.logDetails.duration || "N/A"
            }</p>
            <!-- Aplica la clase 'error' al párrafo si success es No -->
            <p class="${successClass}"><strong>Success:</strong> ${
        logData.logDetails.success ? "Yes" : "No"
      }</p>
            <p><strong>Total Dump File Size:</strong> ${formattedDmpSize}</p> <!-- Aquí -->
            <p><strong>Log File Name:</strong> ${
              logData.logFileName || "N/A"
            }</p>
            <p><strong>Backup Path:</strong> ${
              logData.backupPath || "N/A"
            } (${formattedFolderSize})</p> <!-- Mostrar tamaño de carpeta aquí -->
            <hr>
        `;
      if (logData.logDetails.oraError) {
        entryDiv.dataset.oraError = JSON.stringify(logData.logDetails.oraError);
      }

      logEntriesContainer.appendChild(entryDiv);
      if (resultDiv) resultDiv.style.display = "block";
    }
  }
  let tooltipError = null;
  if (logEntriesContainer) {
    logEntriesContainer.addEventListener("click", function (event) {
      if (event.target && event.target.classList.contains("error-box")) {
        if (!tooltipError) {
          tooltipError = document.createElement("div");
          tooltipError.classList.add("tooltip-error");
          document.body.appendChild(tooltipError);
        }

        const logEntry = event.target.closest(".log-entry");
        const errorDetails = logEntry ? logEntry.dataset.oraError : null;

        if (errorDetails) {
          const oraError = JSON.parse(errorDetails);
          tooltipError.innerHTML = `
                    <p><strong>Error ORA encontrado:</strong></p>
                    <p>${oraError.previousLine}</p>
                    <p><strong>${oraError.errorLine}</strong></p>
                    <p>${oraError.nextLine}</p>
                `;
        } else {
          tooltipError.textContent =
            "No se encontraron detalles específicos del error.";
        }

        const rect = event.target.getBoundingClientRect();
        tooltipError.style.top = `${rect.top + window.scrollY}px`;
        tooltipError.style.left = `${rect.right + 10}px`;
        tooltipError.style.display = "block";
      }
    });
  }

  // Cerrar la ventana flotante cuando se hace clic fuera de ella
  window.onclick = function (event) {
    if (
      tooltipError &&
      !event.target.classList.contains("error-box") &&
      !tooltipError.contains(event.target)
    ) {
      tooltipError.style.display = "none"; // Esconde el tooltip

      // Eliminar el tooltip si ya no es necesario
      tooltipError.remove();
      tooltipError = null;
    }
  };
  const form = document.getElementById("server-form");
  if (form) {
    form.addEventListener("submit", async (event) => {
      event.preventDefault();
      showLoading(); // Mostrar loading overlay

      const ip = ipSelect.value;
      const username = form.username.value;
      const password = form.password.value;

      // Guardar los datos de conexión en el almacenamiento local
      window.localStorage.setItem(
        "connectionData",
        JSON.stringify({ os, ip, port, username, password })
      );

      try {
        // Verificar las credenciales del usuario
        const result = await window.electron.verifyCredentials(
          ip,
          username,
          password
        );

        if (!result.success) {
          throw new Error(result.message); // Lanzar error si la verificación falla
        }

        const os = result.osType;
        const port = result.port;

        // Si el sistema operativo ha cambiado, limpiamos los logs anteriores
        if (currentOS !== os) {
          clearLogEntries();
          currentOS = os; // Actualizamos el sistema operativo actual
        }

        console.log("Connection successful");

        // Obtener las rutas de backup desde la base de datos usando la IP seleccionada
        const backupRoutes = await window.electron.getBackupRoutesByIP(ip);
        let directoryPath = "";

        // Si se encuentran rutas, buscar la correcta según el sistema operativo
        if (backupRoutes.length > 0) {
          const matchingRoute = backupRoutes.find((route) => route.os === os);

          if (matchingRoute) {
            directoryPath = matchingRoute.backupPath; // Asignamos la ruta correcta
            console.log(`Ruta de backup encontrada: ${directoryPath}`);
          } else {
            showAuthErrorModal(
              `No se encontraron rutas para el sistema operativo ${os}`
            );
            return;
          }
        } else {
          showAuthErrorModal("No se encontraron rutas de backup para esta IP.");
          return;
        }

        try {
          // Obtener los detalles del log
          console.log("Fetching log details...");
          const logDetailsArray = await window.electron.getLogDetails(
            directoryPath,
            ip,
            port,
            username,
            password,
            os
          );

          // Procesar los detalles del log
          if (Array.isArray(logDetailsArray)) {
            for (const logData of logDetailsArray) {
              console.log("Adding log entry:", logData);
              addLogEntry({ ...logData, ip });

              if (
                logData.logDetails &&
                Object.keys(logData.logDetails).length > 0
              ) {
                await window.electron.saveLogToDatabase(
                  logData.logDetails,
                  logData.dumpFileInfo,
                  os,
                  logData.logFileName,
                  logData.ip,
                  logData.backupPath
                );
              }
            }
          } else if (logDetailsArray && typeof logDetailsArray === "object") {
            const logData = { ...logDetailsArray, ip };
            console.log("Adding log entry:", logData);
            addLogEntry(logData);

            if (
              logData.logDetails &&
              Object.keys(logData.logDetails).length > 0
            ) {
              await window.electron.saveLogToDatabase(
                logData.logDetails,
                logData.dumpFileInfo,
                os,
                logData.logFileName,
                logData.ip,
                logData.backupPath
              );
            }
          } else {
            console.log(
              "No se encontraron detalles de log o el formato es inesperado:",
              logDetailsArray
            );
            showAuthErrorModal(
              "No se encontraron detalles de log o el formato es inesperado."
            );
          }
        } catch (error) {
          showAuthErrorModal(
            `Error al obtener detalles del log: ${error.message}`
          );
        }
      } catch (error) {
        console.log("Connection error", error);
        showAuthErrorModal(
          error.message ||
            "Error de conexión. Por favor, verifique sus credenciales."
        );
      } finally {
        hideLoading(); // Ocultar loading overlay
      }
    });
  }
});

================
File: select-server.html
================
<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Seleccionar Servidor</title>
  </head>
  <link rel="stylesheet" href="stylesSelect.css" />
  <body>
    <h1>Seleccionar Servidor para Editar</h1>
    <div id="server-list"></div>
    <button id="select-server-btn" disabled>Seleccionar</button>
    <button id="delete-server-btn" disabled>Eliminar</button>
    <!-- Botón para retroceder -->
    <button id="back-button">Volver</button>
    <script>
      document
        .getElementById("back-button")
        .addEventListener("click", function () {
          window.location.href = "index.html"; // Cambia 'index.html' por la página a la que quieras redirigir
        });
    </script>
    <script src="renderer.js"></script>
  </body>
</html>

================
File: stylesAdd.css
================
body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 20px;
  background-color: #f5f5f5;
}

h1 {
  text-align: center;
}

form {
  max-width: 600px;
  margin: 0 auto;
  padding: 20px;
  background: #fff;
  border-radius: 8px;
  box-shadow: 0 0 10px rgba(5, 5, 5, 0.1);
}

label {
  display: block;
  margin-bottom: 8px;
  font-weight: bold;
}

.form-group {
  margin-bottom: 12px;
}

input,
select {
  width: 100%;
  padding: 8px;
  border: 1px solid #ddd;
  border-radius: 4px;
  box-sizing: border-box;
}

button {
  width: 100%;
  padding: 10px;
  background-color: #007bff;
  color: #fff;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
}

button:hover {
  background-color: #0056b3;
}
#back-button {
  width: 200px; /* Ajusta el ancho según prefieras */
  padding: 10px;
  background-color: #6c757d;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
  margin: 20px auto; /* Centra el botón horizontalmente */
  display: block;
}

#back-button:hover {
  background-color: #5a6268;
}
.password-container {
  position: relative;
}

.password-container input[type="password"],
.password-container input[type="text"] {
  width: 100%;
  padding: 8px 30px 8px 8px; /* Increased right padding to make room for the icon */
  border: 1px solid #ddd;
  border-radius: 4px;
  box-sizing: border-box;
}

.toggle-password {
  position: absolute;
  top: 53.5%;
  right: 10px;
  transform: translateY(-50%);
  cursor: pointer;
  color: #007bff;
  font-size: 18px;
}

================
File: stylesEdit.css
================
body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 20px;
  background-color: #f5f5f5;
}

h1 {
  text-align: center;
}

form {
  max-width: 600px;
  margin: 0 auto;
  padding: 20px;
  background: #fff;
  border-radius: 8px;
  box-shadow: 0 0 10px rgba(5, 5, 5, 0.1);
  position: relative;
}

label {
  display: block;
  margin-bottom: 8px;
  font-weight: bold;
}

.form-group {
  margin-bottom: 12px;
}

input,
select {
  width: 100%;
  padding: 8px;
  border: 1px solid #ddd;
  border-radius: 4px;
  box-sizing: border-box;
}

button {
  width: 100%;
  padding: 10px;
  background-color: #007bff;
  color: #fff;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
}

button:hover {
  background-color: #0056b3;
}

#back-button {
  width: 200px;
  padding: 10px;
  background-color: #6c757d;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
  margin: 20px auto;
  display: block;
}

#back-button:hover {
  background-color: #5a6268;
}
.password-container {
  position: relative;
}

.password-container input[type="password"],
.password-container input[type="text"] {
  width: 100%;
  padding: 8px 30px 8px 8px; /* Increased right padding to make room for the icon */
  border: 1px solid #ddd;
  border-radius: 4px;
  box-sizing: border-box;
}

.toggle-password {
  position: absolute;
  top: 53.5%;
  right: 10px;
  transform: translateY(-50%);
  cursor: pointer;
  color: #007bff;
  font-size: 18px;
}

================
File: stylesIndex.css
================
body {
  font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
  background-color: #f0f4f8;
  margin: 0;
  padding: 20px;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  position: relative;
  box-sizing: border-box;
}
.container {
  display: flex;
  flex-direction: column;
  gap: 20px;
  max-width: 600px;
  width: 100%;
}
.card {
  background-color: white;
  border-radius: 12px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
  padding: 20px;
  width: 100%;
  box-sizing: border-box;
}
h1 {
  text-align: center;
  color: #2c3e50;
  margin-bottom: 30px;
  font-size: 28px;
}
form {
  display: flex;
  flex-direction: column;
  gap: 20px;
}
.form-row {
  display: flex;
  gap: 15px;
  margin-bottom: 15px;
}
.form-group {
  flex: 1;
}
label {
  display: block;
  margin-bottom: 8px;
  color: #34495e;
  font-weight: 600;
}
select,
select,
input {
  width: 100%;
  padding: 12px;
  border: 1px solid #bdc3c7;
  border-radius: 6px;
  box-sizing: border-box;
  font-size: 16px;
  transition: border-color 0.3s ease;
  margin-bottom: 10px;
}
select:focus,
input:focus {
  outline: none;
  border-color: #3498db;
}
button {
  background-color: #3498db;
  color: white;
  border: none;
  padding: 14px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 18px;
  font-weight: 600;
  transition: background-color 0.3s ease;
}
button:hover {
  background-color: #2980b9;
}
#loading-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center; /* Centrado horizontal */
  align-items: center; /* Centrado vertical */
  z-index: 9999;
  flex-direction: column; /* Para que el loader y el texto se coloquen uno debajo del otro */
}

.loader {
  border: 5px solid #f3f3f3;
  border-top: 5px solid #3498db;
  border-radius: 50%;
  width: 50px;
  height: 50px;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

#loading-overlay p {
  color: white;
  margin-top: 10px;
  font-size: 18px;
}
/* Estilos para los botones flotantes */
#add-server-btn,
#edit-server-btn {
  position: fixed;
  padding: 15px;
  border: none;
  border-radius: 50%;
  cursor: pointer;
  font-size: 14px;
  width: 60px;
  height: 60px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2);
  z-index: 1000;
  text-align: center;
}
#add-server-btn {
  bottom: 20px;
  right: 20px;
  background-color: #9ae7f5;
  color: rgb(95, 86, 86);
}
#add-server-btn:hover {
  background-color: #49d8fc;
}
#edit-server-btn {
  bottom: 100px;
  right: 20px;
  background-color: #f5b342;
  color: #fff;
}
#edit-server-btn:hover {
  background-color: #e5942a;
}
#add-server-btn i,
#edit-server-btn i {
  font-size: 24px;
  margin-bottom: 5px;
}
#log-entries {
  display: block;
}
#result {
  max-width: 600px;
  margin: 20px auto;
  padding: 20px;
  background: #fff;
  border-radius: 8px;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
  font-size: 16px;
  color: #333;
  display: none; /* Ocultar inicialmente */
}

#result h2 {
  margin-bottom: 10px;
  font-size: 20px;
  color: #007bff;
}

#result p {
  margin: 5px 0;
}

#result p strong {
  color: #333;
}
.modal {
  display: none;
  position: fixed;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  overflow: auto;
  background-color: rgb(0, 0, 0);
  background-color: rgba(0, 0, 0, 0.4);
  z-index: 1000;
}

.modal-content {
  background-color: #fefefe;
  margin: 15% auto;
  padding: 20px;
  border: 1px solid #888;
  width: 80%;
}

.close {
  color: #aaa;
  float: right;
  font-size: 28px;
  font-weight: bold;
}

.close:hover,
.close:focus {
  color: black;
  text-decoration: none;
  cursor: pointer;
}
/* Aplica un recuadro rojo oscuro y fondo claro solo a la línea de Success cuando es No */
.log-entry p.error-box {
  display: inline-block; /* Esto hará que el cuadro se ajuste al tamaño del texto */
  border: 2px solid darkred;
  background-color: #fdd;
  color: darkred;
  padding: 5px;
  border-radius: 5px;
  font-weight: bold;
  cursor: pointer; /* Cambia el cursor a la forma de mano */
  width: 100%; /* Asegura que todo el campo sea clickeable */
}
/* Estilos para la ventana flotante */
.tooltip-error {
  position: absolute;
  background-color: rgba(255, 0, 0, 0.9);
  color: white;
  padding: 10px;
  border-radius: 8px;
  font-size: 14px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  z-index: 1000;
  display: none; /* Oculto por defecto */
}

.tooltip-error::after {
  content: "";
  position: absolute;
  top: 50%;
  left: 100%;
  margin-left: 5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent transparent rgba(255, 0, 0, 0.9);
}
.password-container {
  position: relative;
}

.password-container input[type="password"],
.password-container input[type="text"] {
  width: 100%;
  padding: 8px 30px 8px 8px; /* Increased right padding to make room for the icon */
  border: 1px solid #ddd;
  border-radius: 4px;
  box-sizing: border-box;
}

.toggle-password {
  position: absolute;
  top: 50%;
  right: 12px;
  transform: translateY(-50%);
  cursor: pointer;
  color: #7f8c8d;
  font-size: 18px;
}
#process-all-servers-btn {
  background-color: #2ecc71;
  margin-top: 1px;
  width: 100%;
  margin-bottom: 1px;
  padding: 12px; /* Ajustado para dar más espacio dentro del botón */
  font-size: 16px; /* Ajustado para asegurar que el texto se vea bien */
}
#process-all-servers-btn:hover {
  background-color: #27ae60;
}
#gridContainer {
  margin-top: 30px;
  border-top: 1px solid #e0e0e0;
  padding-top: 30px;
  width: 100%;
  height: calc(100vh - 200px);
}
.grid-wrapper {
  width: 100%;
  overflow-x: auto;
  padding-bottom: 15px;
}
#myGrid {
  width: 100%;
  height: auto;
}
.ag-cell-wrapper {
  word-break: break-word;
}
.ag-root-wrapper {
  border: none !important;
}
/* Ocultar el scroll horizontal del cuerpo del grid */
.ag-body-horizontal-scroll {
  display: none !important;
}
.ag-cell {
  white-space: normal;
  line-height: 1.5em;
}
.process-button-card {
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 15px; /* Ajustado para dar un poco más de espacio alrededor del botón */
  margin-top: 10px;
}

================
File: stylesSelect.css
================
body {
  font-family: "Arial", sans-serif;
  background-color: #f5f5f5;
  margin: 0;
  padding: 20px;
  text-align: center;
}

h1 {
  color: #333;
  font-size: 2.5em;
  margin-bottom: 20px;
}

.server-item {
  background-color: #fff;
  border: 2px solid #ddd;
  padding: 15px;
  margin: 10px auto;
  width: 60%;
  font-size: 1.2em;
  border-radius: 8px;
  transition: background-color 0.3s, border-color 0.3s;
  cursor: pointer;
}

.server-item:hover {
  background-color: #e9e9e9;
  border-color: #007bff;
}

.server-item.selected {
  background-color: #007bff;
  color: white;
  border-color: #007bff;
}

button {
  background-color: #007bff;
  color: white;
  border: none;
  padding: 10px 20px;
  font-size: 1.1em;
  border-radius: 8px;
  cursor: pointer;
  transition: background-color 0.3s;
}

button:disabled {
  background-color: #aaa; /* Color gris para los botones deshabilitados */
  cursor: not-allowed;
}

button#delete-server-btn:disabled {
  background-color: #aaa; /* Cambiar el color cuando está deshabilitado */
}

#delete-server-btn {
  background-color: #dc3545;
}

#delete-server-btn:hover:not(:disabled) {
  background-color: #c82333;
}

#back-button {
  background-color: #6c757d;
  margin-top: 20px;
}

#back-button:hover {
  background-color: #5a6268;
}

.button-group {
  display: flex;
  justify-content: center;
  gap: 10px;
  margin-top: 20px;
}
